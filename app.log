2025-03-31 01:44:19.161 | INFO     | __main__:lifespan:15 - Starting up FastAPI application
2025-03-31 01:44:50.168 | INFO     | __main__:lifespan:17 - Shutting down FastAPI application
2025-03-31 01:44:54.029 | INFO     | __main__:lifespan:15 - Starting up FastAPI application
2025-03-31 01:52:32.582 | INFO     | __main__:lifespan:17 - Shutting down FastAPI application
2025-03-31 01:52:37.716 | INFO     | __main__:lifespan:15 - Starting up FastAPI application
2025-03-31 01:57:08.000 | INFO     | __main__:lifespan:17 - Shutting down FastAPI application
2025-03-31 01:57:13.506 | INFO     | __main__:lifespan:15 - Starting up FastAPI application
2025-03-31 01:57:22.563 | ERROR    | __main__:compare:186 - Failed to parse response: Expecting value: line 1 column 1 (char 0), Response: Okay, I understand. The user has selected category 'Sorting Algorithm' and input size 'Small (n < 10...
2025-03-31 01:57:49.396 | INFO     | __main__:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:00:47.768 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:00:47.768 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:00:56.938 | ERROR    | main:compare:186 - Failed to parse response: Expecting value: line 1 column 1 (char 0), Response: Okay, I understand. Let's proceed with the "Sorting Algorithm" category and "Small (n < 1000)" input...
2025-03-31 02:00:56.938 | ERROR    | main:compare:186 - Failed to parse response: Expecting value: line 1 column 1 (char 0), Response: Okay, I understand. Let's proceed with the "Sorting Algorithm" category and "Small (n < 1000)" input...
2025-03-31 02:05:46.211 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:05:46.211 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:05:49.247 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:05:49.247 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:05:59.906 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:05:59.906 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:06:00.799 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:06:00.799 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:06:10.561 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:06:10.561 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:06:12.986 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:06:12.986 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:06:14.933 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:06:14.933 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:06:17.965 | INFO     | main:compare:165 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 02:06:17.965 | INFO     | main:compare:165 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 02:06:23.551 | INFO     | main:compare:169 - Raw Gemini response (full): Okay, I understand. Let's proceed with the analysis for the **Sorting Algorithms** category and **Small (n < 1000)** input size.

Here's the JSON formatted table comparing Bubble Sort, Merge Sort, Selection Sort, Insertion Sort, Quick Sort, and Heap Sort:

```json
[
  {
    "algorithm": "Bubble Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.250s"
  },
  {
    "algorithm": "Merge Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "execution_time_seconds": "0.005s"
  },
  {
    "algorithm": "Selection Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.125s"
  },
  {
    "algorithm": "Insertion Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.063s"
  },
  {
    "algorithm": "Quick Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(log n)",
    "execution_time_seconds": "0.003s"
  },
  {
    "algorithm": "Heap Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.007s"
  }
]
```

Here is the recommendation and supporting text:

```json
[
    {
        "recommendation": "Quick Sort",
        "insights": "For small input sizes (n < 1000), Quick Sort generally offers the best performance due to its O(n log n) average time complexity and low overhead. Although Merge Sort and Heap Sort also have O(n log n) time complexity, Quick Sort tends to be faster in practice because of its efficient use of the processor cache and fewer memory accesses in typical scenarios. Insertion sort can be faster for very small arrays or nearly sorted arrays, but Quick Sort is consistently faster for larger sizes within the 'small' range.",
        "performance_tips": [
            "Choose a good pivot strategy (e.g., median-of-three) to avoid worst-case O(n^2) behavior.",
            "For very small subarrays (e.g., n < 10), switch to Insertion Sort for better performance.",
            "Implement tail recursion optimization to reduce stack usage."
        ],
        "trade_offs": [
            "Quick Sort is not a stable sorting algorithm, meaning the relative order of equal elements may change.",
            "Worst-case time complexity is O(n^2), although this is rare with a good pivot strategy.",
            "Performance can be sensitive to the initial order of the input data if a naive pivot selection method is used."
        ]
    }
]
```

Recommended Algorithm: Quick Sort

For small input sizes (n < 1000), Quick Sort generally offers the best performance due to its O(n log n) average time complexity and low overhead. Although Merge Sort and Heap Sort also have O(n log n) time complexity, Quick Sort tends to be faster in practice because of its efficient use of the processor cache and fewer memory accesses in typical scenarios. Insertion sort can be faster for very small arrays or nearly sorted arrays, but Quick Sort is consistently faster for larger sizes within the 'small' range.

Performance Tips:
- Choose a good pivot strategy (e.g., median-of-three) to avoid worst-case O(n^2) behavior.
- For very small subarrays (e.g., n < 10), switch to Insertion Sort for better performance.
- Implement tail recursion optimization to reduce stack usage.

Trade-offs:
- Quick Sort is not a stable sorting algorithm, meaning the relative order of equal elements may change.
- Worst-case time complexity is O(n^2), although this is rare with a good pivot strategy.
- Performance can be sensitive to the initial order of the input data if a naive pivot selection method is used.
2025-03-31 02:06:23.551 | INFO     | main:compare:169 - Raw Gemini response (full): Okay, I understand. Let's proceed with the analysis for the **Sorting Algorithms** category and **Small (n < 1000)** input size.

Here's the JSON formatted table comparing Bubble Sort, Merge Sort, Selection Sort, Insertion Sort, Quick Sort, and Heap Sort:

```json
[
  {
    "algorithm": "Bubble Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.250s"
  },
  {
    "algorithm": "Merge Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "execution_time_seconds": "0.005s"
  },
  {
    "algorithm": "Selection Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.125s"
  },
  {
    "algorithm": "Insertion Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.063s"
  },
  {
    "algorithm": "Quick Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(log n)",
    "execution_time_seconds": "0.003s"
  },
  {
    "algorithm": "Heap Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.007s"
  }
]
```

Here is the recommendation and supporting text:

```json
[
    {
        "recommendation": "Quick Sort",
        "insights": "For small input sizes (n < 1000), Quick Sort generally offers the best performance due to its O(n log n) average time complexity and low overhead. Although Merge Sort and Heap Sort also have O(n log n) time complexity, Quick Sort tends to be faster in practice because of its efficient use of the processor cache and fewer memory accesses in typical scenarios. Insertion sort can be faster for very small arrays or nearly sorted arrays, but Quick Sort is consistently faster for larger sizes within the 'small' range.",
        "performance_tips": [
            "Choose a good pivot strategy (e.g., median-of-three) to avoid worst-case O(n^2) behavior.",
            "For very small subarrays (e.g., n < 10), switch to Insertion Sort for better performance.",
            "Implement tail recursion optimization to reduce stack usage."
        ],
        "trade_offs": [
            "Quick Sort is not a stable sorting algorithm, meaning the relative order of equal elements may change.",
            "Worst-case time complexity is O(n^2), although this is rare with a good pivot strategy.",
            "Performance can be sensitive to the initial order of the input data if a naive pivot selection method is used."
        ]
    }
]
```

Recommended Algorithm: Quick Sort

For small input sizes (n < 1000), Quick Sort generally offers the best performance due to its O(n log n) average time complexity and low overhead. Although Merge Sort and Heap Sort also have O(n log n) time complexity, Quick Sort tends to be faster in practice because of its efficient use of the processor cache and fewer memory accesses in typical scenarios. Insertion sort can be faster for very small arrays or nearly sorted arrays, but Quick Sort is consistently faster for larger sizes within the 'small' range.

Performance Tips:
- Choose a good pivot strategy (e.g., median-of-three) to avoid worst-case O(n^2) behavior.
- For very small subarrays (e.g., n < 10), switch to Insertion Sort for better performance.
- Implement tail recursion optimization to reduce stack usage.

Trade-offs:
- Quick Sort is not a stable sorting algorithm, meaning the relative order of equal elements may change.
- Worst-case time complexity is O(n^2), although this is rare with a good pivot strategy.
- Performance can be sensitive to the initial order of the input data if a naive pivot selection method is used.
2025-03-31 02:06:23.551 | ERROR    | main:compare:212 - No valid JSON found in response: Okay, I understand. Let's proceed with the analysis for the **Sorting Algorithms** category and **Sm...
2025-03-31 02:06:23.551 | ERROR    | main:compare:212 - No valid JSON found in response: Okay, I understand. Let's proceed with the analysis for the **Sorting Algorithms** category and **Sm...
2025-03-31 02:06:23.556 | ERROR    | main:compare:221 - Comparison failed: 500: Error: Failed to parse AI response: Expecting value: line 1 column 1 (char 0)
2025-03-31 02:06:23.556 | ERROR    | main:compare:221 - Comparison failed: 500: Error: Failed to parse AI response: Expecting value: line 1 column 1 (char 0)
2025-03-31 02:08:05.547 | INFO     | main:compare:165 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 02:08:05.547 | INFO     | main:compare:165 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 02:08:10.012 | INFO     | main:compare:169 - Raw Gemini response (full): Okay, I understand. Let's proceed with the analysis for **Sorting Algorithms** with **Small (n < 1000)** input size.

```json
[
  {
    "algorithm": "Bubble Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.05s"
  },
  {
    "algorithm": "Merge Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "execution_time_seconds": "0.002s"
  },
  {
    "algorithm": "Selection Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.04s"
  },
  {
    "algorithm": "Insertion Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.02s"
  },
  {
    "algorithm": "Quick Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(log n)",
    "execution_time_seconds": "0.001s"
  },
  {
    "algorithm": "Heap Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.003s"
  }
]
```

```json
[
  {
    "recommendation": "Quick Sort",
    "insights": "For small input sizes (n < 1000), Quick Sort generally offers the best performance due to its O(n log n) average time complexity and relatively low overhead. While Merge Sort and Heap Sort also have O(n log n) complexity, Quick Sort often has better constant factors. Insertion sort can be faster for *nearly* sorted data, but this is not guaranteed. Bubble Sort and Selection Sort are generally inefficient for almost all inputs. The logarithmic space complexity (O(log n)) of Quick Sort also is an advantage for the small size of the input.",
    "performance_tips": [
      "Choose a good pivot:  A median-of-three pivot selection strategy can help avoid worst-case scenarios.",
      "Use insertion sort for small subarrays: Switch to insertion sort when the subarray size becomes small (e.g., < 10-20 elements) as insertion sort has lower overhead in these cases.",
      "Randomize input: Shuffling the input array before sorting can help avoid worst-case behavior if the input is already sorted or nearly sorted."
    ],
    "trade_offs": [
      "Worst-case time complexity: Quick Sort has a worst-case time complexity of O(n^2), which can occur if the pivot is consistently chosen poorly.",
      "Not stable: Quick Sort is not a stable sorting algorithm, meaning that elements with equal values may not maintain their original order after sorting.",
      "Recursive Overhead: The recursive nature of Quick Sort can add some overhead, especially for very small input sizes, but this is usually outweighed by its overall efficiency."
    ]
  }
]
```
2025-03-31 02:08:10.012 | INFO     | main:compare:169 - Raw Gemini response (full): Okay, I understand. Let's proceed with the analysis for **Sorting Algorithms** with **Small (n < 1000)** input size.

```json
[
  {
    "algorithm": "Bubble Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.05s"
  },
  {
    "algorithm": "Merge Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(n)",
    "execution_time_seconds": "0.002s"
  },
  {
    "algorithm": "Selection Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.04s"
  },
  {
    "algorithm": "Insertion Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n^2)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.02s"
  },
  {
    "algorithm": "Quick Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(log n)",
    "execution_time_seconds": "0.001s"
  },
  {
    "algorithm": "Heap Sort",
    "input_size": "Small (n < 1000)",
    "time_complexity": "O(n log n)",
    "space_complexity": "O(1)",
    "execution_time_seconds": "0.003s"
  }
]
```

```json
[
  {
    "recommendation": "Quick Sort",
    "insights": "For small input sizes (n < 1000), Quick Sort generally offers the best performance due to its O(n log n) average time complexity and relatively low overhead. While Merge Sort and Heap Sort also have O(n log n) complexity, Quick Sort often has better constant factors. Insertion sort can be faster for *nearly* sorted data, but this is not guaranteed. Bubble Sort and Selection Sort are generally inefficient for almost all inputs. The logarithmic space complexity (O(log n)) of Quick Sort also is an advantage for the small size of the input.",
    "performance_tips": [
      "Choose a good pivot:  A median-of-three pivot selection strategy can help avoid worst-case scenarios.",
      "Use insertion sort for small subarrays: Switch to insertion sort when the subarray size becomes small (e.g., < 10-20 elements) as insertion sort has lower overhead in these cases.",
      "Randomize input: Shuffling the input array before sorting can help avoid worst-case behavior if the input is already sorted or nearly sorted."
    ],
    "trade_offs": [
      "Worst-case time complexity: Quick Sort has a worst-case time complexity of O(n^2), which can occur if the pivot is consistently chosen poorly.",
      "Not stable: Quick Sort is not a stable sorting algorithm, meaning that elements with equal values may not maintain their original order after sorting.",
      "Recursive Overhead: The recursive nature of Quick Sort can add some overhead, especially for very small input sizes, but this is usually outweighed by its overall efficiency."
    ]
  }
]
```
2025-03-31 02:08:10.012 | ERROR    | main:compare:212 - No valid JSON found in response: Okay, I understand. Let's proceed with the analysis for **Sorting Algorithms** with **Small (n < 100...
2025-03-31 02:08:10.012 | ERROR    | main:compare:212 - No valid JSON found in response: Okay, I understand. Let's proceed with the analysis for **Sorting Algorithms** with **Small (n < 100...
2025-03-31 02:08:10.012 | ERROR    | main:compare:221 - Comparison failed: 500: Error: Failed to parse AI response: Expecting value: line 1 column 1 (char 0)
2025-03-31 02:08:10.012 | ERROR    | main:compare:221 - Comparison failed: 500: Error: Failed to parse AI response: Expecting value: line 1 column 1 (char 0)
2025-03-31 02:08:10.126 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:08:10.126 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:08:12.995 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:08:12.995 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:13:12.416 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:13:12.416 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:13:13.301 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:13:13.301 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 02:13:23.744 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 02:13:23.744 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 02:13:27.719 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.25s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.01s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For small input sizes (n < 1000), Quick Sort and Merge Sort are generally the fastest due to their O(n log n) time complexity. Heap Sort also has similar time complexity. However, Quick Sort tends to perform slightly better in practice due to lower constant factors, making it a good general choice. While Insertion Sort can be fast for nearly sorted data, it degrades to O(n^2) in the worst case. Bubble Sort and Selection Sort are generally slower due to their O(n^2) complexity.",
      "performance_tips": [
        "Choose a good pivot selection strategy (e.g., median-of-three) to avoid worst-case O(n^2) performance.",
        "For very small subarrays (e.g., n < 10), switch to Insertion Sort, which has lower overhead for small sizes.",
        "Consider in-place partitioning to reduce memory usage."
      ],
      "trade_offs": [
        "Quick Sort is not a stable sorting algorithm.",
        "Worst-case time complexity of O(n^2) can occur if the pivot selection is consistently poor.",
        "Can be sensitive to the input data distribution."
      ]
    }
  ]
]
```
2025-03-31 02:13:27.719 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.25s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.01s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For small input sizes (n < 1000), Quick Sort and Merge Sort are generally the fastest due to their O(n log n) time complexity. Heap Sort also has similar time complexity. However, Quick Sort tends to perform slightly better in practice due to lower constant factors, making it a good general choice. While Insertion Sort can be fast for nearly sorted data, it degrades to O(n^2) in the worst case. Bubble Sort and Selection Sort are generally slower due to their O(n^2) complexity.",
      "performance_tips": [
        "Choose a good pivot selection strategy (e.g., median-of-three) to avoid worst-case O(n^2) performance.",
        "For very small subarrays (e.g., n < 10), switch to Insertion Sort, which has lower overhead for small sizes.",
        "Consider in-place partitioning to reduce memory usage."
      ],
      "trade_offs": [
        "Quick Sort is not a stable sorting algorithm.",
        "Worst-case time complexity of O(n^2) can occur if the pivot selection is consistently poor.",
        "Can be sensitive to the input data distribution."
      ]
    }
  ]
]
```
2025-03-31 02:13:27.720 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-03-31 02:13:27.720 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-03-31 02:14:00.006 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 02:14:00.006 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 16:31:54.078 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 16:31:54.078 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-03-31 16:32:07.382 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 16:32:07.382 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 16:32:11.450 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    ...
2025-03-31 16:32:11.450 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    ...
2025-03-31 16:32:21.355 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 16:32:21.355 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-03-31 16:32:25.070 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-03-31 16:32:25.070 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-03-31 16:35:56.037 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-03-31 16:35:56.037 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-03-31 16:35:59.842 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-03-31 16:35:59.842 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-03-31 16:36:11.582 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-03-31 16:36:11.582 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-03-31 16:36:15.297 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-03-31 16:36:15.297 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-03-31 16:47:41.749 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Algorithms, Large (n > 100000)
2025-03-31 16:47:41.749 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Algorithms, Large (n > 100000)
2025-03-31 16:47:44.745 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-03-31 16:47:44.745 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-03-31 16:48:01.713 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Algorithms, Large (n > 100000)
2025-03-31 16:48:01.713 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Algorithms, Large (n > 100000)
2025-03-31 16:48:04.691 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-03-31 16:48:04.691 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-03-31 16:48:22.324 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-03-31 16:48:22.324 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-03-31 16:48:24.641 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation (Recursive)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_s...
2025-03-31 16:48:24.641 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation (Recursive)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_s...
2025-03-31 16:49:05.835 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-03-31 16:49:05.835 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-03-31 16:49:08.056 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-03-31 16:49:08.056 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-03-31 17:30:53.279 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-03-31 17:30:53.279 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 13:58:16.610 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 13:58:16.610 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 13:58:30.250 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 13:58:30.250 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 13:58:34.282 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
   ...
2025-04-01 13:58:34.282 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
   ...
2025-04-01 13:59:34.574 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 13:59:34.574 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 13:59:38.467 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 13:59:38.467 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:11:36.784 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:11:36.784 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:11:41.241 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:11:41.241 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:11:51.687 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:11:51.687 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:11:58.177 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.100s"
  ...
2025-04-01 15:11:58.177 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.100s"
  ...
2025-04-01 15:18:00.775 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:18:00.775 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:18:05.060 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:18:05.060 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:18:14.027 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:18:14.027 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:18:17.608 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:18:17.608 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:18:17.609 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:18:17.609 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:18:20.653 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Merge Sort", "in...
2025-04-01 15:18:20.653 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Merge Sort", "in...
2025-04-01 15:18:22.658 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:18:22.658 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:18:25.565 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Merge Sort", "in...
2025-04-01 15:18:25.565 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Merge Sort", "in...
2025-04-01 15:21:08.289 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:21:08.289 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:21:11.586 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Merge Sort", "in...
2025-04-01 15:21:11.586 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Merge Sort", "in...
2025-04-01 15:21:17.506 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:21:17.506 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:21:21.162 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:21:21.162 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:21:21.163 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:21:21.163 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:21:24.809 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:21:24.809 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:21:28.711 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:21:28.711 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:21:32.598 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:21:32.598 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:22:57.488 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:22:57.488 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:23:01.385 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:23:01.385 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:23:06.364 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:23:06.364 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:23:09.617 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:23:09.617 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:23:11.681 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:23:11.681 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:23:14.913 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5s...
2025-04-01 15:23:14.913 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5s...
2025-04-01 15:23:24.595 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:23:24.595 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:23:28.861 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:23:28.861 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:25:48.322 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:25:48.322 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:25:52.297 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:25:52.297 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:26:49.186 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:26:49.186 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:26:53.397 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:26:53.397 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:26:55.885 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:26:55.885 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:26:59.396 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:26:59.396 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:27:11.908 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:27:11.908 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:27:15.922 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:27:15.922 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:27:48.665 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:27:48.665 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:27:52.546 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:27:52.546 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:27:52.548 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:27:52.548 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:27:56.177 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:27:56.177 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:29:03.917 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:29:03.917 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:29:08.775 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    ...
2025-04-01 15:29:08.775 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    ...
2025-04-01 15:29:10.025 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:29:10.025 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:29:13.719 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:29:13.719 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:32:53.185 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:32:53.185 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:32:56.748 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:32:56.748 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:32:56.956 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:32:56.956 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:33:00.529 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:33:00.529 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:34:16.994 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:34:16.994 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Small (n < 1000)
2025-04-01 15:34:20.759 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:34:20.759 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:34:26.204 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:34:26.204 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Medium (1000 < n < 100000)
2025-04-01 15:34:29.473 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:34:29.473 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:34:32.412 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:34:32.412 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithm, Large (n > 100000)
2025-04-01 15:34:36.591 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:34:36.591 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:34:39.419 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithm, Large (n > 100000)
2025-04-01 15:34:39.419 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithm, Large (n > 100000)
2025-04-01 15:34:42.712 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:34:42.712 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:34:48.175 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithm, Large (n > 100000)
2025-04-01 15:34:48.175 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithm, Large (n > 100000)
2025-04-01 15:34:52.793 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:34:52.793 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:35:27.020 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithm, Large (n > 100000)
2025-04-01 15:35:27.020 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithm, Large (n > 100000)
2025-04-01 15:35:30.291 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000s"
  ...
2025-04-01 15:35:30.291 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000s"
  ...
2025-04-01 15:35:40.168 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:35:40.168 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:35:45.895 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-04-01 15:35:45.895 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-04-01 15:35:52.974 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithm, Large (n > 100000)
2025-04-01 15:35:52.974 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithm, Large (n > 100000)
2025-04-01 15:35:56.600 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000s"
  ...
2025-04-01 15:35:56.600 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000s"
  ...
2025-04-01 15:36:40.413 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 15:36:40.413 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 15:36:44.719 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 15:36:44.719 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 15:36:49.737 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:36:49.737 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:36:56.054 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-04-01 15:36:56.054 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-04-01 15:37:04.232 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:37:04.232 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:37:09.325 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search"...
2025-04-01 15:37:09.325 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search"...
2025-04-01 15:37:13.489 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:37:13.489 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:37:20.058 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:37:20.058 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:37:37.911 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:37:37.911 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:37:43.947 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
 ...
2025-04-01 15:37:43.947 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
 ...
2025-04-01 15:37:50.727 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:37:50.727 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:37:56.955 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:37:56.955 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:38:05.176 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:38:05.176 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:38:10.980 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-04-01 15:38:10.980 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-04-01 15:38:51.567 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:38:51.567 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:38:57.513 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:38:57.513 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:39:15.845 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:39:15.845 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:39:21.389 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:39:21.389 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:40:28.341 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:40:28.341 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:40:32.927 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:40:32.927 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:40:39.772 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E + V log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00002s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.00002s"
    },
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.1s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For a small input size (n < 1000), Quick Sort generally provides the best performance due to its O(n log n) average time complexity and low overhead. While Merge Sort and Heap Sort also have O(n log n) complexity, Quick Sort often performs better in practice for smaller datasets due to its efficient use of the cache.",
      "performance_tips": [
        "Consider a randomized pivot selection to avoid worst-case scenarios.",
        "Implement an optimization like switching to Insertion Sort for subarrays smaller than a certain threshold (e.g., 10-20 elements).",
        "Ensure proper partitioning implementation to minimize overhead."
      ],
      "trade_offs": [
        "Worst-case time complexity is O(n^2), but this is rare with good pivot selection.",
        "Not a stable sorting algorithm, meaning the relative order of equal elements might change.",
        "Performance is sensitive to pivot selection; poor choices can significantly degrade performance."
      ]
    }
  ]
]
```
2025-04-01 15:40:39.772 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E + V log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00002s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.00002s"
    },
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.1s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For a small input size (n < 1000), Quick Sort generally provides the best performance due to its O(n log n) average time complexity and low overhead. While Merge Sort and Heap Sort also have O(n log n) complexity, Quick Sort often performs better in practice for smaller datasets due to its efficient use of the cache.",
      "performance_tips": [
        "Consider a randomized pivot selection to avoid worst-case scenarios.",
        "Implement an optimization like switching to Insertion Sort for subarrays smaller than a certain threshold (e.g., 10-20 elements).",
        "Ensure proper partitioning implementation to minimize overhead."
      ],
      "trade_offs": [
        "Worst-case time complexity is O(n^2), but this is rare with good pivot selection.",
        "Not a stable sorting algorithm, meaning the relative order of equal elements might change.",
        "Performance is sensitive to pivot selection; poor choices can significantly degrade performance."
      ]
    }
  ]
]
```
2025-04-01 15:40:39.782 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
   ...
2025-04-01 15:40:39.782 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
   ...
2025-04-01 15:41:32.458 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:41:32.458 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:41:38.080 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Linear Search", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.1s"},
    {"algorithm": "Binary Search", "input_size": "Large (n > 100000)", "time_complexity": "O(log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.000002s"},
    {"algorithm": "Bubble Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "10s"},
    {"algorithm": "Merge Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n log n)", "space_complexity": "O(n)", "execution_time_seconds": "0.002s"},
    {"algorithm": "Selection Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "5s"},
    {"algorithm": "Insertion Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "5s"},
    {"algorithm": "Quick Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n log n)", "space_complexity": "O(log n)", "execution_time_seconds": "0.002s"},
    {"algorithm": "Heap Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.002s"},
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Large (n > 100000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.1s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Large (n > 100000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.1s"},
    {"algorithm": "Dijkstra’s", "input_size": "Large (n > 100000)", "time_complexity": "O(E + V log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.2s"},
    {"algorithm": "Kruskal", "input_size": "Large (n > 100000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.2s"},
    {"algorithm": "Factorial Calculation", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Tower of Hanoi Calculation", "input_size": "Large (n > 100000)", "time_complexity": "O(2^n)", "space_complexity": "O(n)", "execution_time_seconds": "Too long to compute"}
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For a large dataset, Quick Sort offers a good balance between time and space complexity. Its average time complexity of O(n log n) makes it significantly faster than algorithms with O(n^2) complexity. Although the worst-case time complexity is O(n^2), this can be mitigated by choosing a good pivot strategy. Its space complexity of O(log n) is also efficient compared to algorithms like Merge Sort which require O(n) space.",
      "performance_tips": [
        "Consider using randomized pivot selection to avoid worst-case scenarios.",
        "Use tail recursion optimization where available to limit stack usage.",
        "Switch to insertion sort for small partitions (e.g., size < 10) to improve performance on nearly sorted segments."
      ],
      "trade_offs": [
        "Quick Sort is not a stable sorting algorithm; the relative order of equal elements may change.",
        "Its performance can degrade to O(n^2) with poor pivot choices, especially on already sorted or nearly sorted data.",
        "Requires careful implementation to avoid stack overflow errors for very large inputs due to recursion."
      ]
    }
  ]
]
```
2025-04-01 15:41:38.080 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Linear Search", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.1s"},
    {"algorithm": "Binary Search", "input_size": "Large (n > 100000)", "time_complexity": "O(log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.000002s"},
    {"algorithm": "Bubble Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "10s"},
    {"algorithm": "Merge Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n log n)", "space_complexity": "O(n)", "execution_time_seconds": "0.002s"},
    {"algorithm": "Selection Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "5s"},
    {"algorithm": "Insertion Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "5s"},
    {"algorithm": "Quick Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n log n)", "space_complexity": "O(log n)", "execution_time_seconds": "0.002s"},
    {"algorithm": "Heap Sort", "input_size": "Large (n > 100000)", "time_complexity": "O(n log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.002s"},
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Large (n > 100000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.1s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Large (n > 100000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.1s"},
    {"algorithm": "Dijkstra’s", "input_size": "Large (n > 100000)", "time_complexity": "O(E + V log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.2s"},
    {"algorithm": "Kruskal", "input_size": "Large (n > 100000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.2s"},
    {"algorithm": "Factorial Calculation", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Tower of Hanoi Calculation", "input_size": "Large (n > 100000)", "time_complexity": "O(2^n)", "space_complexity": "O(n)", "execution_time_seconds": "Too long to compute"}
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For a large dataset, Quick Sort offers a good balance between time and space complexity. Its average time complexity of O(n log n) makes it significantly faster than algorithms with O(n^2) complexity. Although the worst-case time complexity is O(n^2), this can be mitigated by choosing a good pivot strategy. Its space complexity of O(log n) is also efficient compared to algorithms like Merge Sort which require O(n) space.",
      "performance_tips": [
        "Consider using randomized pivot selection to avoid worst-case scenarios.",
        "Use tail recursion optimization where available to limit stack usage.",
        "Switch to insertion sort for small partitions (e.g., size < 10) to improve performance on nearly sorted segments."
      ],
      "trade_offs": [
        "Quick Sort is not a stable sorting algorithm; the relative order of equal elements may change.",
        "Its performance can degrade to O(n^2) with poor pivot choices, especially on already sorted or nearly sorted data.",
        "Requires careful implementation to avoid stack overflow errors for very large inputs due to recursion."
      ]
    }
  ]
]
```
2025-04-01 15:41:38.080 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Linear Search", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.1s"},
    {"algorithm": "Binary Search"...
2025-04-01 15:41:38.080 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Linear Search", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.1s"},
    {"algorithm": "Binary Search"...
2025-04-01 15:42:14.954 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:42:14.954 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:42:19.932 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search", "input_size": "Small (n < 1000)", "time_complexity": "O(log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.00001s"},
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Merge Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(n)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Selection Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Insertion Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Quick Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(log n)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Heap Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V+E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V+E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Dijkstra’s", "input_size": "Small (n < 1000)", "time_complexity": "O(E log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Kruskal", "input_size": "Small (n < 1000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Factorial Calculation", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.000001s"},
    {"algorithm": "Tower of Hanoi Calculation", "input_size": "Small (n < 1000)", "time_complexity": "O(2^n)", "space_complexity": "O(n)", "execution_time_seconds": "1e+292s"}
  ],
  [
    {"recommendation": "Quick Sort", "insights": "For small input sizes (n < 1000), Quick Sort generally offers the best performance due to its O(n log n) average-case time complexity and efficient in-place sorting. The constant factors associated with Quick Sort are typically smaller than those of Merge Sort and Heap Sort, making it faster in practice.", "performance_tips": ["Choose a good pivot (e.g., median-of-three)", "Use insertion sort for small subarrays", "Randomize input to avoid worst-case scenarios"], "trade_offs": ["Worst-case time complexity is O(n^2)", "Not a stable sort", "Sensitive to pivot selection"]}
  ]
]
```
2025-04-01 15:42:19.932 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search", "input_size": "Small (n < 1000)", "time_complexity": "O(log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.00001s"},
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Merge Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(n)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Selection Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Insertion Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Quick Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(log n)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Heap Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V+E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V+E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Dijkstra’s", "input_size": "Small (n < 1000)", "time_complexity": "O(E log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Kruskal", "input_size": "Small (n < 1000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Factorial Calculation", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.000001s"},
    {"algorithm": "Tower of Hanoi Calculation", "input_size": "Small (n < 1000)", "time_complexity": "O(2^n)", "space_complexity": "O(n)", "execution_time_seconds": "1e+292s"}
  ],
  [
    {"recommendation": "Quick Sort", "insights": "For small input sizes (n < 1000), Quick Sort generally offers the best performance due to its O(n log n) average-case time complexity and efficient in-place sorting. The constant factors associated with Quick Sort are typically smaller than those of Merge Sort and Heap Sort, making it faster in practice.", "performance_tips": ["Choose a good pivot (e.g., median-of-three)", "Use insertion sort for small subarrays", "Randomize input to avoid worst-case scenarios"], "trade_offs": ["Worst-case time complexity is O(n^2)", "Not a stable sort", "Sensitive to pivot selection"]}
  ]
]
```
2025-04-01 15:42:19.932 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search"...
2025-04-01 15:42:19.932 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search"...
2025-04-01 15:42:44.305 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:42:44.305 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:43:11.244 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:43:11.244 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:43:15.560 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 15:43:15.560 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 15:43:19.699 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.100s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.100s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.500s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.500s"
    }
  ],
  [
    {
      "recommendation": "Breadth-First Search (BFS) or Depth-First Search (DFS)",
      "insights": "For large graphs with over 100,000 nodes, the choice between BFS and DFS depends on the specific application. If the goal is to find the shortest path in an unweighted graph, BFS is generally preferred. If exploring the graph's structure is the primary goal, DFS can be more suitable. Dijkstra's and Kruskal's are appropriate for specific problems (shortest path in weighted graph and minimum spanning tree respectively), but have larger complexities for large graphs.",
      "performance_tips": [
        "Optimize graph representation (e.g., adjacency list vs. matrix).",
        "Avoid redundant visits using a visited set/array.",
        "Utilize parallel processing where applicable."
      ],
      "trade_offs": [
        "BFS can require significantly more memory than DFS, especially for wide graphs.",
        "DFS can get stuck in infinite loops if not implemented carefully for cyclic graphs.",
        "Dijkstra's algorithm is only applicable to graphs with non-negative edge weights, while Kruskal's targets minimum spanning trees."
      ]
    }
  ]
]
```
2025-04-01 15:43:19.699 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.100s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.100s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.500s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.500s"
    }
  ],
  [
    {
      "recommendation": "Breadth-First Search (BFS) or Depth-First Search (DFS)",
      "insights": "For large graphs with over 100,000 nodes, the choice between BFS and DFS depends on the specific application. If the goal is to find the shortest path in an unweighted graph, BFS is generally preferred. If exploring the graph's structure is the primary goal, DFS can be more suitable. Dijkstra's and Kruskal's are appropriate for specific problems (shortest path in weighted graph and minimum spanning tree respectively), but have larger complexities for large graphs.",
      "performance_tips": [
        "Optimize graph representation (e.g., adjacency list vs. matrix).",
        "Avoid redundant visits using a visited set/array.",
        "Utilize parallel processing where applicable."
      ],
      "trade_offs": [
        "BFS can require significantly more memory than DFS, especially for wide graphs.",
        "DFS can get stuck in infinite loops if not implemented carefully for cyclic graphs.",
        "Dijkstra's algorithm is only applicable to graphs with non-negative edge weights, while Kruskal's targets minimum spanning trees."
      ]
    }
  ]
]
```
2025-04-01 15:43:19.700 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 15:43:19.700 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 15:43:30.916 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:43:30.916 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:43:34.877 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.002s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Quick Sort is generally the fastest in practice with an average time complexity of O(n log n) and a space complexity of O(log n). It is an in-place algorithm (except for the recursion stack) and performs well on large datasets. It tends to outperform Merge Sort in practice due to better cache performance. However, its worst-case time complexity is O(n^2), which can occur with poor pivot choices.",
      "performance_tips": [
        "Use randomized pivot selection to avoid worst-case scenarios.",
        "Implement tail recursion optimization to reduce stack usage.",
        "Switch to Insertion Sort for small subarrays to improve performance for nearly sorted portions."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm; equal elements might change order.",
        "Worst-case time complexity is O(n^2), though rare with good pivot selection.",
        "Performance can be sensitive to the initial order of the input data."
      ]
    }
  ]
]
```
2025-04-01 15:43:34.877 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.002s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Quick Sort is generally the fastest in practice with an average time complexity of O(n log n) and a space complexity of O(log n). It is an in-place algorithm (except for the recursion stack) and performs well on large datasets. It tends to outperform Merge Sort in practice due to better cache performance. However, its worst-case time complexity is O(n^2), which can occur with poor pivot choices.",
      "performance_tips": [
        "Use randomized pivot selection to avoid worst-case scenarios.",
        "Implement tail recursion optimization to reduce stack usage.",
        "Switch to Insertion Sort for small subarrays to improve performance for nearly sorted portions."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm; equal elements might change order.",
        "Worst-case time complexity is O(n^2), though rare with good pivot selection.",
        "Performance can be sensitive to the initial order of the input data."
      ]
    }
  ]
]
```
2025-04-01 15:43:34.877 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:43:34.877 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:43:44.943 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:43:44.943 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:43:46.786 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Factorial Calculation (Recursive)", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Tower of Hanoi Calculation (Recursive)", "input_size": "Large (n > 100000)", "time_complexity": "O(2^n)", "space_complexity": "O(n)", "execution_time_seconds": "Does not complete in reasonable time"}
  ],
  [
    {"recommendation": "Factorial Calculation (Recursive)", "insights": "For the large input size and recursion algorithms, Factorial Calculation with O(n) time complexity is more efficient than the Tower of Hanoi calculation which has exponential time complexity O(2^n). The Tower of Hanoi becomes computationally infeasible very quickly as 'n' increases.", "performance_tips": ["Use memoization.", "Consider an iterative approach.", "Optimize base case."], "trade_offs": ["Space complexity increases with recursion depth.", "Stack overflow risk for very large n.", "Overhead of function calls."] }
  ]
]
```
2025-04-01 15:43:46.786 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Factorial Calculation (Recursive)", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Tower of Hanoi Calculation (Recursive)", "input_size": "Large (n > 100000)", "time_complexity": "O(2^n)", "space_complexity": "O(n)", "execution_time_seconds": "Does not complete in reasonable time"}
  ],
  [
    {"recommendation": "Factorial Calculation (Recursive)", "insights": "For the large input size and recursion algorithms, Factorial Calculation with O(n) time complexity is more efficient than the Tower of Hanoi calculation which has exponential time complexity O(2^n). The Tower of Hanoi becomes computationally infeasible very quickly as 'n' increases.", "performance_tips": ["Use memoization.", "Consider an iterative approach.", "Optimize base case."], "trade_offs": ["Space complexity increases with recursion depth.", "Stack overflow risk for very large n.", "Overhead of function calls."] }
  ]
]
```
2025-04-01 15:43:46.787 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Factorial Calculation (Recursive)", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.0001s"},
    {"algo...
2025-04-01 15:43:46.787 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Factorial Calculation (Recursive)", "input_size": "Large (n > 100000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.0001s"},
    {"algo...
2025-04-01 15:44:14.187 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:44:14.187 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:44:17.707 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.01s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:44:17.707 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.01s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:44:17.707 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:44:17.707 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:44:20.647 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:44:20.647 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:44:24.034 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "2.5s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:44:24.034 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "2.5s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:44:24.034 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:44:24.034 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:44:27.853 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 15:44:27.853 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 15:44:31.350 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">50s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">50s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.020s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For large input sizes, Quick Sort generally outperforms other sorting algorithms due to its average-case time complexity of O(n log n) and efficient use of resources. It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider randomized pivot selection to avoid worst-case scenarios.",
        "Implement tail recursion optimization to reduce stack usage.",
        "Switch to insertion sort for small subarrays to improve performance."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm, so the relative order of equal elements may change.",
        "Worst-case time complexity is O(n^2), which can occur with poor pivot choices.",
        "Performance can be highly sensitive to the pivot selection strategy."
      ]
    }
  ]
]
```
2025-04-01 15:44:31.350 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">50s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">50s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.020s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For large input sizes, Quick Sort generally outperforms other sorting algorithms due to its average-case time complexity of O(n log n) and efficient use of resources. It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider randomized pivot selection to avoid worst-case scenarios.",
        "Implement tail recursion optimization to reduce stack usage.",
        "Switch to insertion sort for small subarrays to improve performance."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm, so the relative order of equal elements may change.",
        "Worst-case time complexity is O(n^2), which can occur with poor pivot choices.",
        "Performance can be highly sensitive to the pivot selection strategy."
      ]
    }
  ]
]
```
2025-04-01 15:44:31.350 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:44:31.350 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:44:36.855 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:44:36.855 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:44:39.036 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00000017s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Assuming the data is sorted, it can find the target element much faster.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead.",
        "Optimize the comparison operation if possible."
      ],
      "trade_offs": [
        "Requires the data to be sorted beforehand, which can incur sorting costs.",
        "Only applicable to sorted data.",
        "Not efficient for frequent insertions and deletions."
      ]
    }
  ]
]
```
2025-04-01 15:44:39.036 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00000017s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Assuming the data is sorted, it can find the target element much faster.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead.",
        "Optimize the comparison operation if possible."
      ],
      "trade_offs": [
        "Requires the data to be sorted beforehand, which can incur sorting costs.",
        "Only applicable to sorted data.",
        "Not efficient for frequent insertions and deletions."
      ]
    }
  ]
]
```
2025-04-01 15:44:39.036 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-04-01 15:44:39.036 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001s"
 ...
2025-04-01 15:44:45.223 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:44:45.223 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:44:48.402 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:44:48.402 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:44:48.402 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:44:48.402 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:44:54.745 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:44:54.745 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:44:57.957 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:44:57.957 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:44:57.957 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:44:57.957 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:45:23.197 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 15:45:23.197 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 15:45:25.526 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For small input sizes (n < 1000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. If the data is pre-sorted, Binary Search offers vastly faster search times compared to Linear Search's sequential approach.",
      "performance_tips": [
        "Ensure the data is pre-sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid function call overhead.",
        "For extremely small arrays, linear search might be faster due to the overhead of binary search."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds to the overall time if sorting is not already done.",
        "Not suitable for unsorted data where frequent insertions/deletions occur.",
        "Slightly more complex to implement compared to linear search."
      ]
    }
  ]
]
```
2025-04-01 15:45:25.526 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For small input sizes (n < 1000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. If the data is pre-sorted, Binary Search offers vastly faster search times compared to Linear Search's sequential approach.",
      "performance_tips": [
        "Ensure the data is pre-sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid function call overhead.",
        "For extremely small arrays, linear search might be faster due to the overhead of binary search."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds to the overall time if sorting is not already done.",
        "Not suitable for unsorted data where frequent insertions/deletions occur.",
        "Slightly more complex to implement compared to linear search."
      ]
    }
  ]
]
```
2025-04-01 15:45:25.526 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:45:25.526 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:45:27.328 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:45:27.328 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:45:31.176 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "2500s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For large datasets, Quick Sort generally offers the best average-case performance due to its efficient divide-and-conquer approach. Its O(n log n) average time complexity outperforms algorithms with O(n^2) complexity. While Merge Sort also has O(n log n) complexity, Quick Sort often has better practical performance due to lower constant factors and in-place sorting (though not always guaranteed).",
      "performance_tips": [
        "Choose a good pivot selection strategy (e.g., median-of-three) to avoid worst-case scenarios.",
        "Implement tail recursion optimization to reduce stack overflow risks.",
        "Use Insertion Sort for small subarrays to improve performance on nearly sorted data."
      ],
      "trade_offs": [
        "Worst-case time complexity is O(n^2), which can occur with poor pivot choices.",
        "Not a stable sorting algorithm, meaning the relative order of equal elements may not be preserved.",
        "Performance can vary significantly depending on the pivot selection strategy and input data distribution."
      ]
    }
  ]
]
```
2025-04-01 15:45:31.176 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "2500s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For large datasets, Quick Sort generally offers the best average-case performance due to its efficient divide-and-conquer approach. Its O(n log n) average time complexity outperforms algorithms with O(n^2) complexity. While Merge Sort also has O(n log n) complexity, Quick Sort often has better practical performance due to lower constant factors and in-place sorting (though not always guaranteed).",
      "performance_tips": [
        "Choose a good pivot selection strategy (e.g., median-of-three) to avoid worst-case scenarios.",
        "Implement tail recursion optimization to reduce stack overflow risks.",
        "Use Insertion Sort for small subarrays to improve performance on nearly sorted data."
      ],
      "trade_offs": [
        "Worst-case time complexity is O(n^2), which can occur with poor pivot choices.",
        "Not a stable sorting algorithm, meaning the relative order of equal elements may not be preserved.",
        "Performance can vary significantly depending on the pivot selection strategy and input data distribution."
      ]
    }
  ]
]
```
2025-04-01 15:45:31.176 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000s"
  ...
2025-04-01 15:45:31.176 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000s"
  ...
2025-04-01 15:45:36.207 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:45:36.207 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:45:39.434 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It shows superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:45:39.434 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0002s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It shows superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:45:39.434 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:45:39.434 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:45:43.736 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 15:45:43.736 | INFO     | main:compare:145 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 15:45:47.083 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.01s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For small input sizes, Quick Sort generally performs very well due to its efficient average-case time complexity of O(n log n). The logarithmic space complexity is also beneficial. Although the worst-case is O(n^2), this is rare with proper pivot selection techniques.",
      "performance_tips": [
        "Choose a good pivot (e.g., median-of-three).",
        "Switch to Insertion Sort for small subarrays (e.g., n < 10).",
        "Use randomized Quick Sort to avoid worst-case scenarios."
      ],
      "trade_offs": [
        "Worst-case time complexity can be O(n^2).",
        "Not a stable sorting algorithm.",
        "Performance highly dependent on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:45:47.083 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.01s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For small input sizes, Quick Sort generally performs very well due to its efficient average-case time complexity of O(n log n). The logarithmic space complexity is also beneficial. Although the worst-case is O(n^2), this is rare with proper pivot selection techniques.",
      "performance_tips": [
        "Choose a good pivot (e.g., median-of-three).",
        "Switch to Insertion Sort for small subarrays (e.g., n < 10).",
        "Use randomized Quick Sort to avoid worst-case scenarios."
      ],
      "trade_offs": [
        "Worst-case time complexity can be O(n^2).",
        "Not a stable sorting algorithm.",
        "Performance highly dependent on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:45:47.083 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:45:47.083 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.5s"
    },...
2025-04-01 15:46:13.010 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 15:46:13.010 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 15:46:15.944 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Dijkstra’s", "input_size": "Small (n < 1000)", "time_complexity": "O(E log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Kruskal", "input_size": "Small (n < 1000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.001s"}
  ],
  [
    {"recommendation": "Breadth-First Search (BFS) or Depth-First Search (DFS)", "insights": "For graph traversal within a small graph (n < 1000), both BFS and DFS provide excellent performance with similar time complexities.  The choice between BFS and DFS often depends on the specific problem requirements, such as finding the shortest path versus exploring the entire graph.", "performance_tips": ["Utilize adjacency list representation for efficient neighbor lookup.", "Avoid redundant visits by marking visited nodes.", "Optimize queue/stack operations for BFS/DFS respectively."], "trade_offs": ["Dijkstra’s and Kruskal are better suited for shortest path finding and minimum spanning tree problems, respectively, rather than general graph traversal.", "BFS may require more memory due to queue usage, but it finds shortest path.", "DFS can lead to stack overflow errors in very deep graphs, though this is less likely with small input sizes."]
    }
  ]
]
```
2025-04-01 15:46:15.944 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.0001s"},
    {"algorithm": "Dijkstra’s", "input_size": "Small (n < 1000)", "time_complexity": "O(E log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Kruskal", "input_size": "Small (n < 1000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.001s"}
  ],
  [
    {"recommendation": "Breadth-First Search (BFS) or Depth-First Search (DFS)", "insights": "For graph traversal within a small graph (n < 1000), both BFS and DFS provide excellent performance with similar time complexities.  The choice between BFS and DFS often depends on the specific problem requirements, such as finding the shortest path versus exploring the entire graph.", "performance_tips": ["Utilize adjacency list representation for efficient neighbor lookup.", "Avoid redundant visits by marking visited nodes.", "Optimize queue/stack operations for BFS/DFS respectively."], "trade_offs": ["Dijkstra’s and Kruskal are better suited for shortest path finding and minimum spanning tree problems, respectively, rather than general graph traversal.", "BFS may require more memory due to queue usage, but it finds shortest path.", "DFS can lead to stack overflow errors in very deep graphs, though this is less likely with small input sizes."]
    }
  ]
]
```
2025-04-01 15:46:15.944 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.0001s"},
    {"algorithm...
2025-04-01 15:46:15.944 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.0001s"},
    {"algorithm...
2025-04-01 15:46:18.049 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 15:46:18.049 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 15:46:21.102 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O((V+E)logV)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(ElogE)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.01s"
    }
  ],
  [
    {
      "recommendation": "Breadth-First Search (BFS)",
      "insights": "For graph traversal on medium-sized graphs where finding the shortest path in an unweighted graph is the primary concern, BFS is usually preferred. It systematically explores the graph layer by layer, guaranteeing the shortest path.",
      "performance_tips": [
        "Use an adjacency list to represent the graph.",
        "Optimize queue operations for performance.",
        "Handle visited nodes efficiently."
      ],
      "trade_offs": [
        "Requires significant memory to store nodes at each level.",
        "Not suitable for very deep graphs if memory is limited.",
        "Dijkstra's algorithm is better for weighted graphs."
      ]
    }
  ]
]
```
2025-04-01 15:46:21.102 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O((V+E)logV)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(ElogE)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.01s"
    }
  ],
  [
    {
      "recommendation": "Breadth-First Search (BFS)",
      "insights": "For graph traversal on medium-sized graphs where finding the shortest path in an unweighted graph is the primary concern, BFS is usually preferred. It systematically explores the graph layer by layer, guaranteeing the shortest path.",
      "performance_tips": [
        "Use an adjacency list to represent the graph.",
        "Optimize queue operations for performance.",
        "Handle visited nodes efficiently."
      ],
      "trade_offs": [
        "Requires significant memory to store nodes at each level.",
        "Not suitable for very deep graphs if memory is limited.",
        "Dijkstra's algorithm is better for weighted graphs."
      ]
    }
  ]
]
```
2025-04-01 15:46:21.102 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 15:46:21.102 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 15:46:22.719 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 15:46:22.719 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 15:46:25.935 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.001s"
    }
  ],
  [
    {
      "recommendation": "Breadth-First Search (BFS)",
      "insights": "For large graphs with a large number of nodes and edges (n > 100000), Breadth-First Search is suitable when finding the shortest path between two nodes in an unweighted graph or exploring the graph level by level is crucial. Dijkstra’s algorithm excels for finding the shortest path in a weighted graph, but at the cost of higher time complexity.",
      "performance_tips": [
        "Use adjacency lists to represent the graph efficiently.",
        "Pre-allocate memory for the queue to avoid dynamic resizing.",
        "Optimize node visiting order if some nodes are more likely to be targets."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS due to the queue.",
        "Not suitable for very deep graphs as memory usage grows linearly with the breadth.",
        "Less efficient than Dijkstra's for weighted graphs when searching for shortest paths."
      ]
    }
  ]
]
```
2025-04-01 15:46:25.935 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.001s"
    }
  ],
  [
    {
      "recommendation": "Breadth-First Search (BFS)",
      "insights": "For large graphs with a large number of nodes and edges (n > 100000), Breadth-First Search is suitable when finding the shortest path between two nodes in an unweighted graph or exploring the graph level by level is crucial. Dijkstra’s algorithm excels for finding the shortest path in a weighted graph, but at the cost of higher time complexity.",
      "performance_tips": [
        "Use adjacency lists to represent the graph efficiently.",
        "Pre-allocate memory for the queue to avoid dynamic resizing.",
        "Optimize node visiting order if some nodes are more likely to be targets."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS due to the queue.",
        "Not suitable for very deep graphs as memory usage grows linearly with the breadth.",
        "Less efficient than Dijkstra's for weighted graphs when searching for shortest paths."
      ]
    }
  ]
]
```
2025-04-01 15:46:25.935 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 15:46:25.935 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 15:46:27.802 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 15:46:27.802 | INFO     | main:compare:145 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 15:46:30.901 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.003s"
    }
  ],
  [
    {
      "recommendation": "Breadth-First Search (BFS)",
      "insights": "For graph traversal on small graphs, BFS and DFS are suitable choices, with their time complexities generally proportional to the size of the graph (O(V+E)). For shortest path problems in unweighted graphs, BFS is preferable. Dijkstra's is applicable for weighted graphs, and Kruskal's is optimal for finding minimum spanning trees, but might have higher execution time in certain graph structure.",
      "performance_tips": [
        "Use an adjacency list representation for sparse graphs to reduce memory usage.",
        "Avoid redundant calculations by marking visited nodes.",
        "Optimize queue/stack implementation for BFS/DFS."
      ],
      "trade_offs": [
        "BFS requires more memory than DFS due to the queue.",
        "Dijkstra's has higher overhead than BFS/DFS, not suitable for unweighted graphs.",
        "Kruskal's requires sorting edges, adding complexity."
      ]
    }
  ]
]
```
2025-04-01 15:46:30.901 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.003s"
    }
  ],
  [
    {
      "recommendation": "Breadth-First Search (BFS)",
      "insights": "For graph traversal on small graphs, BFS and DFS are suitable choices, with their time complexities generally proportional to the size of the graph (O(V+E)). For shortest path problems in unweighted graphs, BFS is preferable. Dijkstra's is applicable for weighted graphs, and Kruskal's is optimal for finding minimum spanning trees, but might have higher execution time in certain graph structure.",
      "performance_tips": [
        "Use an adjacency list representation for sparse graphs to reduce memory usage.",
        "Avoid redundant calculations by marking visited nodes.",
        "Optimize queue/stack implementation for BFS/DFS."
      ],
      "trade_offs": [
        "BFS requires more memory than DFS due to the queue.",
        "Dijkstra's has higher overhead than BFS/DFS, not suitable for unweighted graphs.",
        "Kruskal's requires sorting edges, adding complexity."
      ]
    }
  ]
]
```
2025-04-01 15:46:30.901 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds"...
2025-04-01 15:46:30.901 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds"...
2025-04-01 15:46:35.406 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:46:35.406 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:46:41.151 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00000001s"
    },
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000005s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.000005s"
    },
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "1e-297s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:46:41.151 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00000001s"
    },
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000005s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.000005s"
    },
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "1e-297s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:46:41.152 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
 ...
2025-04-01 15:46:41.152 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
 ...
2025-04-01 15:46:42.955 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:46:42.955 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:46:48.590 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00000001s"
    },
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O((V+E) log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:46:48.590 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00000001s"
    },
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O((V+E) log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:46:48.590 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
 ...
2025-04-01 15:46:48.590 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
 ...
2025-04-01 15:46:50.226 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:46:50.226 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:46:52.946 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n) due to recursion depth",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n) due to recursion depth",
      "execution_time_seconds": "Significant, scales rapidly with n. Would likely take many seconds, even minutes for n close to 100000. For n=20, around 0.001s, but grows exponentially."
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For a medium input size (1000 < n < 100000) and recursion algorithms, the factorial calculation will be significantly faster due to its linear time complexity O(n). Tower of Hanoi calculation has exponential time complexity O(2^n), rendering it impractical for large values of n.",
      "performance_tips": [
        "Use iterative approach if possible to avoid recursion overhead.",
        "Implement memoization to store intermediate results.",
        "Consider using tail recursion if supported by the language."
      ],
      "trade_offs": [
        "Recursion can lead to stack overflow errors for very large n.",
        "Space complexity is O(n) due to the call stack.",
        "Recursive calls can be slower than iterative loops due to function call overhead."
      ]
    }
  ]
]
```
2025-04-01 15:46:52.946 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n) due to recursion depth",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n) due to recursion depth",
      "execution_time_seconds": "Significant, scales rapidly with n. Would likely take many seconds, even minutes for n close to 100000. For n=20, around 0.001s, but grows exponentially."
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For a medium input size (1000 < n < 100000) and recursion algorithms, the factorial calculation will be significantly faster due to its linear time complexity O(n). Tower of Hanoi calculation has exponential time complexity O(2^n), rendering it impractical for large values of n.",
      "performance_tips": [
        "Use iterative approach if possible to avoid recursion overhead.",
        "Implement memoization to store intermediate results.",
        "Consider using tail recursion if supported by the language."
      ],
      "trade_offs": [
        "Recursion can lead to stack overflow errors for very large n.",
        "Space complexity is O(n) due to the call stack.",
        "Recursive calls can be slower than iterative loops due to function call overhead."
      ]
    }
  ]
]
```
2025-04-01 15:46:52.946 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n) due to recursion depth",
    ...
2025-04-01 15:46:52.946 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n) due to recursion depth",
    ...
2025-04-01 15:46:56.268 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:46:56.268 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:46:58.791 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation (Recursive)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation (Recursive)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "> 1 year"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation (Recursive)",
      "insights": "For large n, the factorial calculation using recursion is feasible, unlike the Tower of Hanoi, which grows exponentially. The linear time complexity of O(n) is manageable, while the space complexity of O(n) is due to the call stack. However, iterative approaches are still more efficient for Factorial.",
      "performance_tips": [
        "Use tail-call optimization if the language supports it to reduce space complexity.",
        "Consider using an iterative approach instead of recursion for better space efficiency.",
        "Implement memoization to store calculated factorial values and reduce computation for smaller numbers if called repeatedly."
      ],
      "trade_offs": [
        "Recursion can be limited by stack size constraints, possibly leading to stack overflow errors.",
        "Iterative approaches are generally faster and more memory-efficient than recursive approaches for Factorial.",
        "For very large numbers, arbitrary-precision arithmetic might be required, impacting performance."
      ]
    }
  ]
]
```
2025-04-01 15:46:58.791 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation (Recursive)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation (Recursive)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "> 1 year"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation (Recursive)",
      "insights": "For large n, the factorial calculation using recursion is feasible, unlike the Tower of Hanoi, which grows exponentially. The linear time complexity of O(n) is manageable, while the space complexity of O(n) is due to the call stack. However, iterative approaches are still more efficient for Factorial.",
      "performance_tips": [
        "Use tail-call optimization if the language supports it to reduce space complexity.",
        "Consider using an iterative approach instead of recursion for better space efficiency.",
        "Implement memoization to store calculated factorial values and reduce computation for smaller numbers if called repeatedly."
      ],
      "trade_offs": [
        "Recursion can be limited by stack size constraints, possibly leading to stack overflow errors.",
        "Iterative approaches are generally faster and more memory-efficient than recursive approaches for Factorial.",
        "For very large numbers, arbitrary-precision arithmetic might be required, impacting performance."
      ]
    }
  ]
]
```
2025-04-01 15:46:58.791 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation (Recursive)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_s...
2025-04-01 15:46:58.791 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation (Recursive)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_s...
2025-04-01 15:47:00.940 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:47:00.940 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:47:05.601 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search", "input_size": "Small (n < 1000)", "time_complexity": "O(log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.00001s"},
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Merge Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(n)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Selection Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Insertion Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.25s"},
    {"algorithm": "Quick Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(log n)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Heap Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Dijkstra’s", "input_size": "Small (n < 1000)", "time_complexity": "O(E log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Kruskal", "input_size": "Small (n < 1000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Factorial Calculation", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Tower of Hanoi Calculation", "input_size": "Small (n < 1000)", "time_complexity": "O(2^n)", "space_complexity": "O(n)", "execution_time_seconds": "1e280s"}
  ],
  [
    {"recommendation": "Quick Sort", "insights": "Based on your input size and requirements, Quick Sort performs best with O(n log n) average time complexity and relatively minimal space usage (O(log n) average). It showed superior performance in benchmarks for the given dataset size.", "performance_tips": ["Consider pivot selection strategy", "Implement tail-call optimization", "Use insertion sort for small subarrays"], "trade_offs": ["Not a stable sorting algorithm", "Worst-case O(n^2) time complexity is possible", "Performance highly depends on pivot choice"]}
  ]
]
```
2025-04-01 15:47:05.601 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search", "input_size": "Small (n < 1000)", "time_complexity": "O(log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.00001s"},
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Merge Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(n)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Selection Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.5s"},
    {"algorithm": "Insertion Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.25s"},
    {"algorithm": "Quick Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(log n)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Heap Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Dijkstra’s", "input_size": "Small (n < 1000)", "time_complexity": "O(E log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Kruskal", "input_size": "Small (n < 1000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.01s"},
    {"algorithm": "Factorial Calculation", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(n)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Tower of Hanoi Calculation", "input_size": "Small (n < 1000)", "time_complexity": "O(2^n)", "space_complexity": "O(n)", "execution_time_seconds": "1e280s"}
  ],
  [
    {"recommendation": "Quick Sort", "insights": "Based on your input size and requirements, Quick Sort performs best with O(n log n) average time complexity and relatively minimal space usage (O(log n) average). It showed superior performance in benchmarks for the given dataset size.", "performance_tips": ["Consider pivot selection strategy", "Implement tail-call optimization", "Use insertion sort for small subarrays"], "trade_offs": ["Not a stable sorting algorithm", "Worst-case O(n^2) time complexity is possible", "Performance highly depends on pivot choice"]}
  ]
]
```
2025-04-01 15:47:05.601 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search"...
2025-04-01 15:47:05.601 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {"algorithm": "Linear Search", "input_size": "Small (n < 1000)", "time_complexity": "O(n)", "space_complexity": "O(1)", "execution_time_seconds": "0.001s"},
    {"algorithm": "Binary Search"...
2025-04-01 15:47:10.138 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:47:10.138 | INFO     | main:compare:145 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:47:15.834 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00000001s"
    },
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:47:15.834 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00000001s"
    },
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000002s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.00001s"
    },
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:47:15.835 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
 ...
2025-04-01 15:47:15.835 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000001s"
 ...
2025-04-01 15:49:58.063 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:49:58.063 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:50:01.328 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.010s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average).",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:50:01.328 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.010s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average).",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:50:01.328 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    ...
2025-04-01 15:50:01.328 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.500s"
    ...
2025-04-01 15:50:13.032 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:50:13.032 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:50:17.066 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000166s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.000166s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000166s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For medium-sized datasets, Quick Sort generally offers the best performance due to its efficient average-case time complexity. It performs in-place sorting with a small overhead, making it suitable when memory is a concern. Although merge sort and heap sort offer the same time complexity they will be slightly slower due to overhead.",
      "performance_tips": [
        "Choose a good pivot selection strategy (e.g., median-of-three) to avoid worst-case scenarios.",
        "Implement tail recursion optimization to reduce stack usage.",
        "Switch to insertion sort for smaller subarrays (e.g., less than 10-20 elements) to improve performance."
      ],
      "trade_offs": [
        "Quick Sort is not a stable sorting algorithm, meaning the relative order of equal elements may change.",
        "The worst-case time complexity is O(n^2), which can occur with poor pivot selection.",
        "Performance can be sensitive to the choice of pivot element."
      ]
    }
  ]
]
```
2025-04-01 15:50:17.066 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000166s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.0s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.000166s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000166s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For medium-sized datasets, Quick Sort generally offers the best performance due to its efficient average-case time complexity. It performs in-place sorting with a small overhead, making it suitable when memory is a concern. Although merge sort and heap sort offer the same time complexity they will be slightly slower due to overhead.",
      "performance_tips": [
        "Choose a good pivot selection strategy (e.g., median-of-three) to avoid worst-case scenarios.",
        "Implement tail recursion optimization to reduce stack usage.",
        "Switch to insertion sort for smaller subarrays (e.g., less than 10-20 elements) to improve performance."
      ],
      "trade_offs": [
        "Quick Sort is not a stable sorting algorithm, meaning the relative order of equal elements may change.",
        "The worst-case time complexity is O(n^2), which can occur with poor pivot selection.",
        "Performance can be sensitive to the choice of pivot element."
      ]
    }
  ]
]
```
2025-04-01 15:50:17.066 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:50:17.066 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5....
2025-04-01 15:50:24.568 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 15:50:24.568 | INFO     | main:compare:145 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 15:50:28.498 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.02s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">50s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">50s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.015s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.025s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For large datasets (n > 100000), Quick Sort generally offers the best performance due to its average-case time complexity of O(n log n) and relatively low space overhead. While Merge Sort and Heap Sort also offer O(n log n) time complexity, Quick Sort often has better constant factors, leading to faster execution in practice. However, it's crucial to mitigate its worst-case O(n^2) behavior through careful pivot selection.",
      "performance_tips": [
        "Choose a good pivot (e.g., median-of-three).",
        "Use randomized pivot selection to avoid worst-case scenarios.",
        "Switch to insertion sort for small subarrays (e.g., n < 10) for optimization."
      ],
      "trade_offs": [
        "Unstable sort (preserves order of equal elements).",
        "Worst-case time complexity can be O(n^2) with poor pivot selection.",
        "Implementation can be more complex than some other sorting algorithms (e.g., Bubble Sort)."
      ]
    }
  ]
]
```
2025-04-01 15:50:28.498 | INFO     | main:compare:149 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.02s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">50s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">50s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.015s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.025s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "For large datasets (n > 100000), Quick Sort generally offers the best performance due to its average-case time complexity of O(n log n) and relatively low space overhead. While Merge Sort and Heap Sort also offer O(n log n) time complexity, Quick Sort often has better constant factors, leading to faster execution in practice. However, it's crucial to mitigate its worst-case O(n^2) behavior through careful pivot selection.",
      "performance_tips": [
        "Choose a good pivot (e.g., median-of-three).",
        "Use randomized pivot selection to avoid worst-case scenarios.",
        "Switch to insertion sort for small subarrays (e.g., n < 10) for optimization."
      ],
      "trade_offs": [
        "Unstable sort (preserves order of equal elements).",
        "Worst-case time complexity can be O(n^2) with poor pivot selection.",
        "Implementation can be more complex than some other sorting algorithms (e.g., Bubble Sort)."
      ]
    }
  ]
]
```
2025-04-01 15:50:28.498 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:50:28.498 | INFO     | main:compare:177 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": ">100s"
   ...
2025-04-01 15:50:33.613 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:50:33.613 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:50:36.562 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:50:36.562 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:50:41.556 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:50:41.556 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:50:45.145 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:50:45.145 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:50:45.145 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:50:45.145 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:50:46.451 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:50:46.451 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:50:49.858 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:50:49.858 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:50:49.858 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:50:49.858 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:50:55.790 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:50:55.790 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:50:59.379 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It often demonstrates the fastest practical performance compared to other algorithms with the same time complexity. The estimated time is for the average case. Choosing an effective pivot is key to its performance.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization (where applicable)",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible, but very rare with good pivot selection",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:50:59.379 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.002s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.002s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It often demonstrates the fastest practical performance compared to other algorithms with the same time complexity. The estimated time is for the average case. Choosing an effective pivot is key to its performance.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization (where applicable)",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible, but very rare with good pivot selection",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:50:59.379 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10.000s"
 ...
2025-04-01 15:50:59.379 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10.000s"
 ...
2025-04-01 15:51:46.183 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:51:46.183 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:51:49.868 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size. While Merge Sort and Heap Sort also have O(n log n) complexities, Quick Sort generally has better constant factors, making it faster in practice. The execution times provided are estimates and actual times can vary.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:51:49.868 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size. While Merge Sort and Heap Sort also have O(n log n) complexities, Quick Sort generally has better constant factors, making it faster in practice. The execution times provided are estimates and actual times can vary.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization",
        "Use insertion sort for small subarrays"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:51:49.868 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:51:49.868 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:52:10.649 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:52:10.649 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:52:13.632 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:52:13.632 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:52:16.822 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:52:16.822 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:52:24.059 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:52:24.059 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:52:26.534 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000017s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For large input sizes (n > 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Binary Search requires the input data to be sorted, but the cost of sorting (if not already sorted) is often offset by the performance gains in subsequent searches. Linear search becomes prohibitively slow for large datasets.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative approach to avoid potential stack overflow issues with very large datasets (though this is less relevant with modern compilers).",
        "Implement early exit conditions if the target element is found quickly."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, adding overhead if the data is not already sorted.",
        "Only applicable to sorted data; cannot be used directly on unsorted datasets.",
        "Space complexity is O(1) meaning it doesn't need extra space but needs the data to be sorted"
      ]
    }
  ]
]
```
2025-04-01 15:52:26.534 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000017s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For large input sizes (n > 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Binary Search requires the input data to be sorted, but the cost of sorting (if not already sorted) is often offset by the performance gains in subsequent searches. Linear search becomes prohibitively slow for large datasets.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative approach to avoid potential stack overflow issues with very large datasets (though this is less relevant with modern compilers).",
        "Implement early exit conditions if the target element is found quickly."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, adding overhead if the data is not already sorted.",
        "Only applicable to sorted data; cannot be used directly on unsorted datasets.",
        "Space complexity is O(1) meaning it doesn't need extra space but needs the data to be sorted"
      ]
    }
  ]
]
```
2025-04-01 15:52:26.534 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
   ...
2025-04-01 15:52:26.534 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
   ...
2025-04-01 15:52:27.904 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:52:27.904 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:52:30.257 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00002s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For large datasets where the data is sorted, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Linear Search has to check each element in the worst case, while Binary Search eliminates half of the remaining elements in each step. The estimated execution time highlights this difference dramatically.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using an iterative implementation of Binary Search to avoid potential stack overflow issues for extremely large datasets.",
        "Use appropriate error handling to manage cases where the target element is not found."
      ],
      "trade_offs": [
        "Requires the data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Not suitable for unsorted data.",
        "Only applicable when direct access to elements is possible (e.g., arrays)."
      ]
    }
  ]
]
```
2025-04-01 15:52:30.257 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00002s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For large datasets where the data is sorted, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Linear Search has to check each element in the worst case, while Binary Search eliminates half of the remaining elements in each step. The estimated execution time highlights this difference dramatically.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using an iterative implementation of Binary Search to avoid potential stack overflow issues for extremely large datasets.",
        "Use appropriate error handling to manage cases where the target element is not found."
      ],
      "trade_offs": [
        "Requires the data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Not suitable for unsorted data.",
        "Only applicable when direct access to elements is possible (e.g., arrays)."
      ]
    }
  ]
]
```
2025-04-01 15:52:30.258 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
   ...
2025-04-01 15:52:30.258 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
   ...
2025-04-01 15:52:33.045 | INFO     | main:compare:141 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 15:52:33.045 | INFO     | main:compare:141 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 15:52:36.645 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It typically outperforms Merge Sort and Heap Sort in practice due to lower constant factors, although worst-case performance can be O(n^2).",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:52:36.645 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It typically outperforms Merge Sort and Heap Sort in practice due to lower constant factors, although worst-case performance can be O(n^2).",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 15:52:36.646 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:52:36.646 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:52:39.203 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:52:39.203 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:52:41.677 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00002s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For large input sizes (n > 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Binary search requires the data to be sorted, adding the overhead of a sorting algorithm if the data is not already sorted. However, for a single or small number of lookups, even adding the sorting step may be worthwhile. If the data is already sorted and searches occur frequently, binary search is much better.",
      "performance_tips": [
        "Ensure the data is sorted before performing Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead.",
        "Be aware of potential integer overflow issues when calculating the middle index in some languages."
      ],
      "trade_offs": [
        "Requires pre-sorted data.",
        "Not suitable for unsorted or frequently changing data without re-sorting.",
        "Only applicable if direct access to elements is possible (e.g., arrays)."
      ]
    }
  ]
]
```
2025-04-01 15:52:41.677 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00002s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For large input sizes (n > 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Binary search requires the data to be sorted, adding the overhead of a sorting algorithm if the data is not already sorted. However, for a single or small number of lookups, even adding the sorting step may be worthwhile. If the data is already sorted and searches occur frequently, binary search is much better.",
      "performance_tips": [
        "Ensure the data is sorted before performing Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead.",
        "Be aware of potential integer overflow issues when calculating the middle index in some languages."
      ],
      "trade_offs": [
        "Requires pre-sorted data.",
        "Not suitable for unsorted or frequently changing data without re-sorting.",
        "Only applicable if direct access to elements is possible (e.g., arrays)."
      ]
    }
  ]
]
```
2025-04-01 15:52:41.677 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
   ...
2025-04-01 15:52:41.677 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
   ...
2025-04-01 15:52:44.646 | INFO     | main:compare:141 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 15:52:44.646 | INFO     | main:compare:141 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 15:52:48.707 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort is typically the best option.",
      "insights": "With a large dataset like yours, algorithms with O(n^2) complexity (Bubble, Selection, and Insertion Sort) will take impractically long. While Merge Sort and Heap Sort offer O(n log n) time complexity, Quick Sort often performs the best in practice due to lower constant factors, assuming a good pivot selection strategy is employed. Heap Sort has guaranteed O(n log n) and O(1) space, making it good for specific scenarios. Merge sort guarantees O(n log n) but requires O(n) space.",
      "performance_tips": [
        "Consider pivot selection strategy (e.g., median-of-three).",
        "Implement tail-call optimization or iterative approach to reduce stack usage.",
        "Use insertion sort for small subarrays (e.g., < 16 elements) after partitioning."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm (elements with equal keys might change their relative order).",
        "Worst-case O(n^2) time complexity is possible with poor pivot choices.",
        "Performance highly depends on the initial order of the input array."
      ]
    }
  ]
]
```
2025-04-01 15:52:48.707 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.017s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "5000.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.014s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.023s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort is typically the best option.",
      "insights": "With a large dataset like yours, algorithms with O(n^2) complexity (Bubble, Selection, and Insertion Sort) will take impractically long. While Merge Sort and Heap Sort offer O(n log n) time complexity, Quick Sort often performs the best in practice due to lower constant factors, assuming a good pivot selection strategy is employed. Heap Sort has guaranteed O(n log n) and O(1) space, making it good for specific scenarios. Merge sort guarantees O(n log n) but requires O(n) space.",
      "performance_tips": [
        "Consider pivot selection strategy (e.g., median-of-three).",
        "Implement tail-call optimization or iterative approach to reduce stack usage.",
        "Use insertion sort for small subarrays (e.g., < 16 elements) after partitioning."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm (elements with equal keys might change their relative order).",
        "Worst-case O(n^2) time complexity is possible with poor pivot choices.",
        "Performance highly depends on the initial order of the input array."
      ]
    }
  ]
]
```
2025-04-01 15:52:48.707 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:52:48.707 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10000.000s...
2025-04-01 15:52:49.781 | INFO     | main:compare:141 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:52:49.781 | INFO     | main:compare:141 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:52:53.510 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "100.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.020s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "50.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "50.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.015s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.025s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Quick Sort",
      "insights": "For the input size provided (1000 < n < 100000), Quick Sort generally outperforms other algorithms due to its average-case time complexity of O(n log n) and efficient in-place sorting. Although Merge Sort and Heap Sort also have O(n log n) time complexity, Quick Sort usually has lower constant factors, making it faster in practice. Bubble Sort, Selection Sort, and Insertion Sort all have O(n^2) time complexity, making them unsuitable for larger datasets.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization (if applicable to your language)",
        "Use insertion sort for small subarrays (hybrid approach)"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:52:53.510 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "100.000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.020s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "50.000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "50.000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.015s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.025s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Quick Sort",
      "insights": "For the input size provided (1000 < n < 100000), Quick Sort generally outperforms other algorithms due to its average-case time complexity of O(n log n) and efficient in-place sorting. Although Merge Sort and Heap Sort also have O(n log n) time complexity, Quick Sort usually has lower constant factors, making it faster in practice. Bubble Sort, Selection Sort, and Insertion Sort all have O(n^2) time complexity, making them unsuitable for larger datasets.",
      "performance_tips": [
        "Consider pivot selection strategy",
        "Implement tail-call optimization (if applicable to your language)",
        "Use insertion sort for small subarrays (hybrid approach)"
      ],
      "trade_offs": [
        "Not a stable sorting algorithm",
        "Worst-case O(n^2) time complexity is possible",
        "Performance highly depends on pivot choice"
      ]
    }
  ]
]
```
2025-04-01 15:52:53.510 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10...
2025-04-01 15:52:53.510 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "10...
2025-04-01 15:52:55.625 | INFO     | main:compare:141 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:52:55.625 | INFO     | main:compare:141 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 15:52:58.743 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.500s"},
    {"algorithm": "Merge Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(n)", "execution_time_seconds": "0.010s"},
    {"algorithm": "Selection Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.500s"},
    {"algorithm": "Insertion Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.500s"},
    {"algorithm": "Quick Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(log n)", "execution_time_seconds": "0.010s"},
    {"algorithm": "Heap Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.010s"}
  ],
  [
    {"recommendation": "Recommended Algorithm: Quick Sort", "insights": "For small input sizes (n < 1000), Quick Sort, Merge Sort, and Heap Sort are generally the fastest due to their O(n log n) time complexity. Quick Sort often performs the best in practice due to its lower constant factors, making it faster than Merge Sort and Heap Sort on average. However, its worst-case time complexity is O(n^2). Insertion sort can be faster for nearly sorted data or very small datasets.", "performance_tips": ["Consider pivot selection strategy.", "Implement tail-call optimization.", "Use insertion sort for small subarrays."], "trade_offs": ["Not a stable sorting algorithm.", "Worst-case O(n^2) time complexity is possible.", "Performance highly depends on pivot choice."]}
  ]
]
```
2025-04-01 15:52:58.743 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.500s"},
    {"algorithm": "Merge Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(n)", "execution_time_seconds": "0.010s"},
    {"algorithm": "Selection Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.500s"},
    {"algorithm": "Insertion Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.500s"},
    {"algorithm": "Quick Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(log n)", "execution_time_seconds": "0.010s"},
    {"algorithm": "Heap Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n log n)", "space_complexity": "O(1)", "execution_time_seconds": "0.010s"}
  ],
  [
    {"recommendation": "Recommended Algorithm: Quick Sort", "insights": "For small input sizes (n < 1000), Quick Sort, Merge Sort, and Heap Sort are generally the fastest due to their O(n log n) time complexity. Quick Sort often performs the best in practice due to its lower constant factors, making it faster than Merge Sort and Heap Sort on average. However, its worst-case time complexity is O(n^2). Insertion sort can be faster for nearly sorted data or very small datasets.", "performance_tips": ["Consider pivot selection strategy.", "Implement tail-call optimization.", "Use insertion sort for small subarrays."], "trade_offs": ["Not a stable sorting algorithm.", "Worst-case O(n^2) time complexity is possible.", "Performance highly depends on pivot choice."]}
  ]
]
```
2025-04-01 15:52:58.743 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.500s"},
    {"algorithm": "Merge Sort", "...
2025-04-01 15:52:58.743 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {"algorithm": "Bubble Sort", "input_size": "Small (n < 1000)", "time_complexity": "O(n^2)", "space_complexity": "O(1)", "execution_time_seconds": "0.500s"},
    {"algorithm": "Merge Sort", "...
2025-04-01 15:53:04.830 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 15:53:04.830 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 15:53:07.767 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For small input sizes (n < 1000), Binary Search generally outperforms Linear Search due to its logarithmic time complexity. However, Binary Search requires the input array to be sorted, which introduces an overhead if the array isn't already sorted. If the array is frequently searched, the initial sorting cost is amortized over multiple searches, making Binary Search more efficient. Linear Search is simpler to implement and doesn't require a sorted input, making it suitable for unsorted arrays or situations where the array is only searched once or a few times.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative implementation of Binary Search to avoid potential stack overflow issues with very large datasets (though unlikely with n < 1000).",
        "Be mindful of integer overflow when calculating the midpoint in Binary Search; use mid = low + (high - low) / 2 instead of mid = (low + high) / 2."
      ],
      "trade_offs": [
        "Binary Search requires a sorted input array, whereas Linear Search does not.",
        "Binary Search has a better time complexity (O(log n)) than Linear Search (O(n)) for sorted arrays.",
        "Linear Search is simpler to implement than Binary Search."
      ]
    }
  ]
]
```
2025-04-01 15:53:07.767 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00001s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For small input sizes (n < 1000), Binary Search generally outperforms Linear Search due to its logarithmic time complexity. However, Binary Search requires the input array to be sorted, which introduces an overhead if the array isn't already sorted. If the array is frequently searched, the initial sorting cost is amortized over multiple searches, making Binary Search more efficient. Linear Search is simpler to implement and doesn't require a sorted input, making it suitable for unsorted arrays or situations where the array is only searched once or a few times.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative implementation of Binary Search to avoid potential stack overflow issues with very large datasets (though unlikely with n < 1000).",
        "Be mindful of integer overflow when calculating the midpoint in Binary Search; use mid = low + (high - low) / 2 instead of mid = (low + high) / 2."
      ],
      "trade_offs": [
        "Binary Search requires a sorted input array, whereas Linear Search does not.",
        "Binary Search has a better time complexity (O(log n)) than Linear Search (O(n)) for sorted arrays.",
        "Linear Search is simpler to implement than Binary Search."
      ]
    }
  ]
]
```
2025-04-01 15:53:07.768 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:53:07.768 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001s"
    ...
2025-04-01 15:53:09.126 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:53:09.126 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:53:11.813 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.050s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000017s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For medium-sized datasets, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. However, Binary Search requires the data to be sorted beforehand.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using iterative implementation for slight performance improvement.",
        "Be mindful of integer overflow when calculating the middle index (mid = low + (high - low) / 2)."
      ],
      "trade_offs": [
        "Requires pre-sorted data, which incurs an additional sorting cost if the data is not already sorted.",
        "Not suitable for unsorted data.",
        "Only applicable for data structures that allow efficient random access (e.g., arrays)."
      ]
    }
  ]
]
```
2025-04-01 15:53:11.813 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.050s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000017s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For medium-sized datasets, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. However, Binary Search requires the data to be sorted beforehand.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using iterative implementation for slight performance improvement.",
        "Be mindful of integer overflow when calculating the middle index (mid = low + (high - low) / 2)."
      ],
      "trade_offs": [
        "Requires pre-sorted data, which incurs an additional sorting cost if the data is not already sorted.",
        "Not suitable for unsorted data.",
        "Only applicable for data structures that allow efficient random access (e.g., arrays)."
      ]
    }
  ]
]
```
2025-04-01 15:53:11.813 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 15:53:11.813 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 15:53:13.794 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:53:13.794 | INFO     | main:compare:141 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 15:53:16.443 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00002s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For large datasets where the data is already sorted, Binary Search is significantly faster than Linear Search due to its logarithmic time complexity. Linear Search requires checking each element one by one until the target is found (or the entire list is traversed), while Binary Search efficiently narrows down the search space by half in each step.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative approach rather than recursion to avoid stack overflow issues with very large datasets.",
        "Be mindful of integer overflow when calculating the middle index (especially in languages like Java or C++) by using `mid = low + (high - low) / 2` instead of `(low + high) / 2`."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data isn't already sorted.",
        "Only applicable when searching for a specific value in a sorted list.",
        "Less efficient than hash table lookups if the dataset can fit in memory and extra space for the hash table is acceptable."
      ]
    }
  ]
]
```
2025-04-01 15:53:16.443 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00002s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Binary Search",
      "insights": "For large datasets where the data is already sorted, Binary Search is significantly faster than Linear Search due to its logarithmic time complexity. Linear Search requires checking each element one by one until the target is found (or the entire list is traversed), while Binary Search efficiently narrows down the search space by half in each step.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative approach rather than recursion to avoid stack overflow issues with very large datasets.",
        "Be mindful of integer overflow when calculating the middle index (especially in languages like Java or C++) by using `mid = low + (high - low) / 2` instead of `(low + high) / 2`."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data isn't already sorted.",
        "Only applicable when searching for a specific value in a sorted list.",
        "Less efficient than hash table lookups if the dataset can fit in memory and extra space for the hash table is acceptable."
      ]
    }
  ]
]
```
2025-04-01 15:53:16.444 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
   ...
2025-04-01 15:53:16.444 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.05s"
   ...
2025-04-01 15:53:19.998 | INFO     | main:compare:141 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 15:53:19.998 | INFO     | main:compare:141 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 15:53:23.698 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.1s-100s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.1s-100s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V) (using priority queue)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.5s-500s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E) or O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.5s-500s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: BFS or DFS (depending on specific use case), Dijkstra's or Kruskal's",
      "insights": "For a large graph (n > 100000), the choice between BFS and DFS depends on the problem. BFS is suitable for finding the shortest path in unweighted graphs, while DFS is efficient for exploring connectivity and cycles. Dijkstra's algorithm is best for finding shortest paths in weighted graphs where edge weights are non-negative. Kruskal's is used for finding the minimum spanning tree, connecting all nodes with minimum total edge weight. The estimated execution times are highly dependent on the specific graph structure (sparse vs. dense) and hardware.",
      "performance_tips": [
        "Optimize graph representation (e.g., adjacency list for sparse graphs).",
        "Use efficient data structures for priority queues in Dijkstra's (e.g., binary heap or Fibonacci heap).",
        "Minimize memory allocation and deallocation within the traversal loops."
      ],
      "trade_offs": [
        "BFS requires more memory than DFS in wide graphs.",
        "Dijkstra's doesn't work with negative edge weights.",
        "Kruskal's requires sorting edges, which can be a bottleneck for very large graphs."
      ]
    }
  ]
]
```
2025-04-01 15:53:23.698 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.1s-100s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.1s-100s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V) (using priority queue)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.5s-500s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E) or O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.5s-500s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: BFS or DFS (depending on specific use case), Dijkstra's or Kruskal's",
      "insights": "For a large graph (n > 100000), the choice between BFS and DFS depends on the problem. BFS is suitable for finding the shortest path in unweighted graphs, while DFS is efficient for exploring connectivity and cycles. Dijkstra's algorithm is best for finding shortest paths in weighted graphs where edge weights are non-negative. Kruskal's is used for finding the minimum spanning tree, connecting all nodes with minimum total edge weight. The estimated execution times are highly dependent on the specific graph structure (sparse vs. dense) and hardware.",
      "performance_tips": [
        "Optimize graph representation (e.g., adjacency list for sparse graphs).",
        "Use efficient data structures for priority queues in Dijkstra's (e.g., binary heap or Fibonacci heap).",
        "Minimize memory allocation and deallocation within the traversal loops."
      ],
      "trade_offs": [
        "BFS requires more memory than DFS in wide graphs.",
        "Dijkstra's doesn't work with negative edge weights.",
        "Kruskal's requires sorting edges, which can be a bottleneck for very large graphs."
      ]
    }
  ]
]
```
2025-04-01 15:53:23.698 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 15:53:23.698 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 15:53:26.147 | INFO     | main:compare:141 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 15:53:26.147 | INFO     | main:compare:141 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 15:53:29.634 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V) or O(V^2) (depending on implementation)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.003s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E) or O(E log V)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.004s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Breadth-First Search (BFS) or Depth-First Search (DFS)",
      "insights": "For small graphs (n < 1000), the choice between BFS and DFS largely depends on the specific problem. If the goal is to find the shortest path in an unweighted graph, BFS is preferred. If exploring deeply into the graph is needed or checking for cycles, DFS might be better. Dijkstra's and Kruskal are typically for more complex graph problems like shortest paths in weighted graphs or minimum spanning trees, respectively. The relatively small scale makes the constant factors more impactful than asymptotic behavior for BFS and DFS, yielding comparable speeds.",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs.",
        "Avoid redundant computations by keeping track of visited nodes.",
        "Optimize queue/stack operations if applicable."
      ],
      "trade_offs": [
        "BFS requires more memory due to the queue, especially for wide graphs.",
        "DFS can lead to stack overflow for very deep graphs if recursion isn't managed carefully.",
        "Dijkstra’s is generally slower for unweighted graphs compared to BFS because of the priority queue operations."
      ]
    }
  ]
]
```
2025-04-01 15:53:29.634 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V) or O(V^2) (depending on implementation)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.003s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E) or O(E log V)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.004s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Breadth-First Search (BFS) or Depth-First Search (DFS)",
      "insights": "For small graphs (n < 1000), the choice between BFS and DFS largely depends on the specific problem. If the goal is to find the shortest path in an unweighted graph, BFS is preferred. If exploring deeply into the graph is needed or checking for cycles, DFS might be better. Dijkstra's and Kruskal are typically for more complex graph problems like shortest paths in weighted graphs or minimum spanning trees, respectively. The relatively small scale makes the constant factors more impactful than asymptotic behavior for BFS and DFS, yielding comparable speeds.",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs.",
        "Avoid redundant computations by keeping track of visited nodes.",
        "Optimize queue/stack operations if applicable."
      ],
      "trade_offs": [
        "BFS requires more memory due to the queue, especially for wide graphs.",
        "DFS can lead to stack overflow for very deep graphs if recursion isn't managed carefully.",
        "Dijkstra’s is generally slower for unweighted graphs compared to BFS because of the priority queue operations."
      ]
    }
  ]
]
```
2025-04-01 15:53:29.634 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds"...
2025-04-01 15:53:29.634 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V+E)",
      "space_complexity": "O(V)",
      "execution_time_seconds"...
2025-04-01 15:53:31.699 | INFO     | main:compare:141 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 15:53:31.699 | INFO     | main:compare:141 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 15:53:35.344 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O((|V| + |E|)log|V|)",
      "space_complexity": "O(|V|)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(|E|log|E|)",
      "space_complexity": "O(|V|)",
      "execution_time_seconds": "0.1s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Breadth-First Search (BFS) or Depth-First Search (DFS)",
      "insights": "For graph traversal in medium-sized graphs, BFS and DFS offer the best balance between speed and resource usage. Dijkstra's algorithm is designed for finding the shortest path in a weighted graph, not for general traversal, and Kruskal's algorithm calculates the Minimum Spanning Tree and isn't appropriate for general traversal either. The execution time is based on the assumption that |E| is proportional to |V| in medium size graphs.",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs.",
        "Avoid redundant node visits by marking visited nodes.",
        "Optimize queue/stack implementation for BFS/DFS."
      ],
      "trade_offs": [
        "BFS: Finds the shortest path but may require more memory.",
        "DFS: May not find the shortest path, but is more memory-efficient.",
        "Dijkstra’s: Much slower for general traversal, optimal for shortest path finding. Kruskal’s only gives MST, unsuitable for traversal."
      ]
    }
  ]
]
```
2025-04-01 15:53:35.344 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)",
      "execution_time_seconds": "0.01s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O((|V| + |E|)log|V|)",
      "space_complexity": "O(|V|)",
      "execution_time_seconds": "0.05s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(|E|log|E|)",
      "space_complexity": "O(|V|)",
      "execution_time_seconds": "0.1s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Breadth-First Search (BFS) or Depth-First Search (DFS)",
      "insights": "For graph traversal in medium-sized graphs, BFS and DFS offer the best balance between speed and resource usage. Dijkstra's algorithm is designed for finding the shortest path in a weighted graph, not for general traversal, and Kruskal's algorithm calculates the Minimum Spanning Tree and isn't appropriate for general traversal either. The execution time is based on the assumption that |E| is proportional to |V| in medium size graphs.",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs.",
        "Avoid redundant node visits by marking visited nodes.",
        "Optimize queue/stack implementation for BFS/DFS."
      ],
      "trade_offs": [
        "BFS: Finds the shortest path but may require more memory.",
        "DFS: May not find the shortest path, but is more memory-efficient.",
        "Dijkstra’s: Much slower for general traversal, optimal for shortest path finding. Kruskal’s only gives MST, unsuitable for traversal."
      ]
    }
  ]
]
```
2025-04-01 15:53:35.344 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)",
      "execu...
2025-04-01 15:53:35.344 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(|V| + |E|)",
      "space_complexity": "O(|V|)",
      "execu...
2025-04-01 15:53:39.273 | INFO     | main:compare:141 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:53:39.273 | INFO     | main:compare:141 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:53:41.844 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Exceeds reasonable time."
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For medium input sizes (1000 < n < 100000), calculating the factorial recursively has linear time complexity O(n), making it quite efficient. However, Tower of Hanoi quickly becomes computationally expensive due to its exponential time complexity. It's important to note that factorial calculation can also lead to integer overflow with larger values of n depending on the data type used.",
      "performance_tips": [
        "Use memoization for potentially repeated subproblems.",
        "Consider iterative approach for space optimization if stack overflow is a concern with large n.",
        "Choose appropriate data type to avoid integer overflow."
      ],
      "trade_offs": [
        "Recursive factorial can lead to stack overflow for very large n.",
        "Tower of Hanoi is only feasible for smaller values of n due to exponential growth.",
        "Recursive solutions may have higher overhead compared to iterative."
      ]
    }
  ]
]
```
2025-04-01 15:53:41.844 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Exceeds reasonable time."
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For medium input sizes (1000 < n < 100000), calculating the factorial recursively has linear time complexity O(n), making it quite efficient. However, Tower of Hanoi quickly becomes computationally expensive due to its exponential time complexity. It's important to note that factorial calculation can also lead to integer overflow with larger values of n depending on the data type used.",
      "performance_tips": [
        "Use memoization for potentially repeated subproblems.",
        "Consider iterative approach for space optimization if stack overflow is a concern with large n.",
        "Choose appropriate data type to avoid integer overflow."
      ],
      "trade_offs": [
        "Recursive factorial can lead to stack overflow for very large n.",
        "Tower of Hanoi is only feasible for smaller values of n due to exponential growth.",
        "Recursive solutions may have higher overhead compared to iterative."
      ]
    }
  ]
]
```
2025-04-01 15:53:41.844 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 15:53:41.844 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 15:53:43.713 | INFO     | main:compare:141 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:53:43.713 | INFO     | main:compare:141 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:53:46.326 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For small values of 'n' (n < 1000), the factorial calculation using recursion is significantly faster and more efficient than the Tower of Hanoi calculation. While both utilize recursion, the factorial computation has a linear time complexity, whereas the Tower of Hanoi has an exponential complexity. Thus, for computing factorials within the specified range, it's the superior choice.",
      "performance_tips": [
        "Implement memoization, although the depth of recursion is small with n<1000.",
        "Check base case for 0 or 1 to prevent stack overflow errors.",
        "Ensure your chosen language implementation supports tail-call optimization"
      ],
      "trade_offs": [
        "Factorial can overflow quickly for large values of n, consider using libraries that support arbitrary-precision arithmetic if larger factorials are needed.",
        "Recursive factorial might have stack overflow issues with certain very large values of n (though this won't be an issue for n < 1000).",
        "The iterative implementation of Factorial would have lower space complexity (O(1))."
      ]
    }
  ]
]
```
2025-04-01 15:53:46.326 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For small values of 'n' (n < 1000), the factorial calculation using recursion is significantly faster and more efficient than the Tower of Hanoi calculation. While both utilize recursion, the factorial computation has a linear time complexity, whereas the Tower of Hanoi has an exponential complexity. Thus, for computing factorials within the specified range, it's the superior choice.",
      "performance_tips": [
        "Implement memoization, although the depth of recursion is small with n<1000.",
        "Check base case for 0 or 1 to prevent stack overflow errors.",
        "Ensure your chosen language implementation supports tail-call optimization"
      ],
      "trade_offs": [
        "Factorial can overflow quickly for large values of n, consider using libraries that support arbitrary-precision arithmetic if larger factorials are needed.",
        "Recursive factorial might have stack overflow issues with certain very large values of n (though this won't be an issue for n < 1000).",
        "The iterative implementation of Factorial would have lower space complexity (O(1))."
      ]
    }
  ]
]
```
2025-04-01 15:53:46.327 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 15:53:46.327 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 15:53:48.519 | INFO     | main:compare:141 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:53:48.519 | INFO     | main:compare:141 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 15:53:50.994 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too long for practical calculation"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For a medium input size (1000 < n < 100000), factorial calculation is significantly more efficient than Tower of Hanoi due to its linear time complexity compared to the exponential time complexity of Tower of Hanoi. Tower of Hanoi becomes computationally infeasible very quickly as n increases.",
      "performance_tips": [
        "Use memoization or dynamic programming for multiple calculations of the same factorial.",
        "Iterative approach may be faster in some cases",
        "Optimize multiplication operations for large numbers."
      ],
      "trade_offs": [
        "Recursion can lead to stack overflow for very large n (though input size limits this).",
        "Iterative approach might be harder to read.",
        "Limited by hardware floating-point precision for larger n."
      ]
    }
  ]
]
```
2025-04-01 15:53:50.994 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too long for practical calculation"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For a medium input size (1000 < n < 100000), factorial calculation is significantly more efficient than Tower of Hanoi due to its linear time complexity compared to the exponential time complexity of Tower of Hanoi. Tower of Hanoi becomes computationally infeasible very quickly as n increases.",
      "performance_tips": [
        "Use memoization or dynamic programming for multiple calculations of the same factorial.",
        "Iterative approach may be faster in some cases",
        "Optimize multiplication operations for large numbers."
      ],
      "trade_offs": [
        "Recursion can lead to stack overflow for very large n (though input size limits this).",
        "Iterative approach might be harder to read.",
        "Limited by hardware floating-point precision for larger n."
      ]
    }
  ]
]
```
2025-04-01 15:53:50.995 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 15:53:50.995 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 15:54:00.351 | INFO     | main:compare:141 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:54:00.351 | INFO     | main:compare:141 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:54:03.148 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too Large"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For very large n, factorial calculation using recursion is practical as it is an O(n) operation. However, Tower of Hanoi with O(2^n) complexity will take exponentially longer and would likely be impractical to complete even on modern hardware. Therefore, if you intend to calculate results in a reasonable timeframe, Factorial Calculation is recommended. Note that for extremely large n, the size of the factorial result itself might exceed practical memory limitations.",
      "performance_tips": [
        "Utilize memoization techniques to store intermediate factorial results if needed for further calculations.",
        "Employ iterative method instead of recursion to improve performance.",
        "Consider handling potential stack overflow for very large 'n' by using tail recursion optimization (if supported by the compiler) or converting to an iterative approach."
      ],
      "trade_offs": [
        "Recursive factorial calculation has higher space complexity O(n) due to function call stack compared to O(1) iterative approach.",
        "For Tower of Hanoi, the time complexity grows exponentially, quickly making it unusable for large 'n'.",
        "Factorial Calculation can result in very large numbers quickly, potentially exceeding the limits of standard data types."
      ]
    }
  ]
]
```
2025-04-01 15:54:03.148 | INFO     | main:compare:145 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too Large"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For very large n, factorial calculation using recursion is practical as it is an O(n) operation. However, Tower of Hanoi with O(2^n) complexity will take exponentially longer and would likely be impractical to complete even on modern hardware. Therefore, if you intend to calculate results in a reasonable timeframe, Factorial Calculation is recommended. Note that for extremely large n, the size of the factorial result itself might exceed practical memory limitations.",
      "performance_tips": [
        "Utilize memoization techniques to store intermediate factorial results if needed for further calculations.",
        "Employ iterative method instead of recursion to improve performance.",
        "Consider handling potential stack overflow for very large 'n' by using tail recursion optimization (if supported by the compiler) or converting to an iterative approach."
      ],
      "trade_offs": [
        "Recursive factorial calculation has higher space complexity O(n) due to function call stack compared to O(1) iterative approach.",
        "For Tower of Hanoi, the time complexity grows exponentially, quickly making it unusable for large 'n'.",
        "Factorial Calculation can result in very large numbers quickly, potentially exceeding the limits of standard data types."
      ]
    }
  ]
]
```
2025-04-01 15:54:03.148 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 15:54:03.148 | INFO     | main:compare:173 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 15:57:15.441 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:57:15.441 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:57:18.391 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:57:18.391 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:59:13.658 | INFO     | main:compare:147 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:59:13.658 | INFO     | main:compare:147 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:59:16.372 | INFO     | main:compare:151 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "inf"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, the recursive Tower of Hanoi is computationally infeasible. Factorial calculation is linear and thus much faster, though it will eventually overflow standard integer types. Consider using arbitrary-precision arithmetic for larger factorials.",
      "performance_tips": [
        "Use memoization to avoid redundant calculations (though this is most helpful for overlapping subproblems, not simple factorial).",
        "Consider iterative implementation to avoid call stack overhead.",
        "If using arbitrary-precision arithmetic, choose a library optimized for large number calculations."
      ],
      "trade_offs": [
        "Factorial is efficient for calculation, but will quickly become larger than standard data types can hold.",
        "Tower of Hanoi's exponential complexity makes it impractical for anything beyond small inputs.",
        "Factorial uses recursion, but is tail recursive and can be easily converted to an iterative solution."
      ]
    }
  ]
]
```
2025-04-01 15:59:16.372 | INFO     | main:compare:151 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "inf"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, the recursive Tower of Hanoi is computationally infeasible. Factorial calculation is linear and thus much faster, though it will eventually overflow standard integer types. Consider using arbitrary-precision arithmetic for larger factorials.",
      "performance_tips": [
        "Use memoization to avoid redundant calculations (though this is most helpful for overlapping subproblems, not simple factorial).",
        "Consider iterative implementation to avoid call stack overhead.",
        "If using arbitrary-precision arithmetic, choose a library optimized for large number calculations."
      ],
      "trade_offs": [
        "Factorial is efficient for calculation, but will quickly become larger than standard data types can hold.",
        "Tower of Hanoi's exponential complexity makes it impractical for anything beyond small inputs.",
        "Factorial uses recursion, but is tail recursive and can be easily converted to an iterative solution."
      ]
    }
  ]
]
```
2025-04-01 15:59:16.372 | INFO     | main:compare:179 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 15:59:16.372 | INFO     | main:compare:179 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 15:59:23.847 | INFO     | main:compare:147 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:59:23.847 | INFO     | main:compare:147 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 15:59:26.517 | INFO     | main:compare:151 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004s"
    }
  ],
  [
    {
      "recommendation": "Tower of Hanoi Calculation",
      "insights": "While both algorithms are recursive, the Tower of Hanoi calculation has a time complexity of O(2^n) which makes it significantly more computationally intensive than Factorial Calculation's O(n) as n increases. However, for very small n (less than 10), the actual execution time difference might be negligible due to overhead. For the input size considered, Tower of Hanoi might be slightly faster, although Factorial Calculation is always better to use when possible due to its time complexity and is more cache friendly.",
      "performance_tips": [
        "Implement memoization if repetitive subproblems arise (though unlikely for simple factorial or basic Hanoi).",
        "Optimize base case handling for factorial (return 1 if n=0 or n=1).",
        "Consider using iterative solutions to reduce stack overhead."
      ],
      "trade_offs": [
        "Factorial Calculation has a linear runtime, so it scales much better for very large n, whereas Tower of Hanoi has a exponential runtime.",
        "Factorial Calculation uses more space when implemented recursively.",
        "Tower of Hanoi has higher time complexity, making it unsuitable for large input sizes."
      ]
    }
  ]
]
```
2025-04-01 15:59:26.517 | INFO     | main:compare:151 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004s"
    }
  ],
  [
    {
      "recommendation": "Tower of Hanoi Calculation",
      "insights": "While both algorithms are recursive, the Tower of Hanoi calculation has a time complexity of O(2^n) which makes it significantly more computationally intensive than Factorial Calculation's O(n) as n increases. However, for very small n (less than 10), the actual execution time difference might be negligible due to overhead. For the input size considered, Tower of Hanoi might be slightly faster, although Factorial Calculation is always better to use when possible due to its time complexity and is more cache friendly.",
      "performance_tips": [
        "Implement memoization if repetitive subproblems arise (though unlikely for simple factorial or basic Hanoi).",
        "Optimize base case handling for factorial (return 1 if n=0 or n=1).",
        "Consider using iterative solutions to reduce stack overhead."
      ],
      "trade_offs": [
        "Factorial Calculation has a linear runtime, so it scales much better for very large n, whereas Tower of Hanoi has a exponential runtime.",
        "Factorial Calculation uses more space when implemented recursively.",
        "Tower of Hanoi has higher time complexity, making it unsuitable for large input sizes."
      ]
    }
  ]
]
```
2025-04-01 15:59:26.517 | INFO     | main:compare:179 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 15:59:26.517 | INFO     | main:compare:179 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 15:59:29.071 | INFO     | main:compare:147 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:59:29.071 | INFO     | main:compare:147 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 15:59:31.820 | INFO     | main:compare:151 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "INF"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large input sizes, the Tower of Hanoi calculation becomes computationally infeasible due to its exponential time complexity. Factorial calculation, while still potentially leading to very large numbers requiring arbitrary-precision arithmetic, has a linear time complexity and hence is far more practical for n > 100000. Note that even factorial calculation can run into memory issues, or stack overflow problems, if you implement it recursively with a very large 'n'. An iterative approach to factorial computation would be more appropriate.",
      "performance_tips": [
        "Use an iterative approach for factorial to avoid stack overflow.",
        "Employ memoization if multiple factorials are needed.",
        "Utilize arbitrary-precision arithmetic libraries to handle large numbers."
      ],
      "trade_offs": [
        "Factorial calculation can still result in very large numbers, requiring careful memory management.",
        "The recursive nature of Tower of Hanoi significantly limits its practicality for large input sizes.",
        "Iterative solutions to factorial calculations have similar time complexity, but smaller space complexity."
      ]
    }
  ]
]
```
2025-04-01 15:59:31.820 | INFO     | main:compare:151 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "INF"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large input sizes, the Tower of Hanoi calculation becomes computationally infeasible due to its exponential time complexity. Factorial calculation, while still potentially leading to very large numbers requiring arbitrary-precision arithmetic, has a linear time complexity and hence is far more practical for n > 100000. Note that even factorial calculation can run into memory issues, or stack overflow problems, if you implement it recursively with a very large 'n'. An iterative approach to factorial computation would be more appropriate.",
      "performance_tips": [
        "Use an iterative approach for factorial to avoid stack overflow.",
        "Employ memoization if multiple factorials are needed.",
        "Utilize arbitrary-precision arithmetic libraries to handle large numbers."
      ],
      "trade_offs": [
        "Factorial calculation can still result in very large numbers, requiring careful memory management.",
        "The recursive nature of Tower of Hanoi significantly limits its practicality for large input sizes.",
        "Iterative solutions to factorial calculations have similar time complexity, but smaller space complexity."
      ]
    }
  ]
]
```
2025-04-01 15:59:31.820 | INFO     | main:compare:179 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 15:59:31.820 | INFO     | main:compare:179 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 15:59:36.927 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:59:36.927 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 15:59:39.827 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 15:59:39.827 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 16:00:57.170 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:00:57.170 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:00:59.886 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "error"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, Tower of Hanoi is infeasible due to its exponential time complexity. Factorial calculation with O(n) time complexity is significantly more practical for n = 1,000,000. The Tower of Hanoi quickly becomes intractable.",
      "performance_tips": [
        "Use memoization to store previously calculated factorial values, although the benefit is minimal with pure recursion.",
        "Consider iterative implementations for slight performance improvements.",
        "Be mindful of integer overflow for very large factorials; use appropriate data types or libraries."
      ],
      "trade_offs": [
        "Factorial recursion has a space complexity of O(n) due to the call stack, which can be a concern for extremely large n.",
        "The recursive implementation might be slightly slower than an iterative one due to function call overhead.",
        "Limited applicability beyond relatively small n due to the rapid growth of the factorial function."
      ]
    }
  ]
]
```
2025-04-01 16:00:59.886 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "error"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, Tower of Hanoi is infeasible due to its exponential time complexity. Factorial calculation with O(n) time complexity is significantly more practical for n = 1,000,000. The Tower of Hanoi quickly becomes intractable.",
      "performance_tips": [
        "Use memoization to store previously calculated factorial values, although the benefit is minimal with pure recursion.",
        "Consider iterative implementations for slight performance improvements.",
        "Be mindful of integer overflow for very large factorials; use appropriate data types or libraries."
      ],
      "trade_offs": [
        "Factorial recursion has a space complexity of O(n) due to the call stack, which can be a concern for extremely large n.",
        "The recursive implementation might be slightly slower than an iterative one due to function call overhead.",
        "Limited applicability beyond relatively small n due to the rapid growth of the factorial function."
      ]
    }
  ]
]
```
2025-04-01 16:00:59.886 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:00:59.886 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:01:05.636 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:05.636 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:08.296 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "N/A"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the given input size (1000 < n < 100000), calculating the factorial using a recursive approach is significantly more efficient than solving the Tower of Hanoi problem. The Tower of Hanoi has exponential time complexity, making it impractical for even moderately sized 'n' values in this range due to potential stack overflow with recursion and computation time. While Factorial also has O(n) space complexity for recursive call stack, stack overflow will happen earlier for Tower of Hanoi.",
      "performance_tips": [
        "Use iterative approach for large n.",
        "Implement tail recursion optimization (if possible in your language).",
        "Consider memoization (though benefit is minimal for simple factorial)."
      ],
      "trade_offs": [
        "Recursive factorial can hit stack overflow limits for very large n.",
        "Iterative factorial uses constant space.",
        "Factorial growth rate is significant; result will quickly exceed integer limits, requiring arbitrary-precision arithmetic."
      ]
    }
  ]
]
```
2025-04-01 16:01:08.296 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "N/A"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the given input size (1000 < n < 100000), calculating the factorial using a recursive approach is significantly more efficient than solving the Tower of Hanoi problem. The Tower of Hanoi has exponential time complexity, making it impractical for even moderately sized 'n' values in this range due to potential stack overflow with recursion and computation time. While Factorial also has O(n) space complexity for recursive call stack, stack overflow will happen earlier for Tower of Hanoi.",
      "performance_tips": [
        "Use iterative approach for large n.",
        "Implement tail recursion optimization (if possible in your language).",
        "Consider memoization (though benefit is minimal for simple factorial)."
      ],
      "trade_offs": [
        "Recursive factorial can hit stack overflow limits for very large n.",
        "Iterative factorial uses constant space.",
        "Factorial growth rate is significant; result will quickly exceed integer limits, requiring arbitrary-precision arithmetic."
      ]
    }
  ]
]
```
2025-04-01 16:01:08.296 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:08.296 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:10.433 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:10.433 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:12.927 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too long to execute"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For medium input sizes, calculating the factorial recursively is generally faster than the Tower of Hanoi problem due to its linear time complexity compared to exponential time complexity. Tower of Hanoi would require too long to execute.",
      "performance_tips": [
        "Consider memoization for smaller input sizes if the factorial is needed multiple times.",
        "Tail recursion optimization can improve performance, depending on the compiler.",
        "For extremely large n, use iterative approaches or specialized libraries to avoid stack overflow."
      ],
      "trade_offs": [
        "Recursive factorial calculation can lead to stack overflow for large 'n'.",
        "Iterative approaches may be faster for large inputs due to lower overhead.",
        "Space complexity can be significant for deep recursion."
      ]
    }
  ]
]
```
2025-04-01 16:01:12.927 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too long to execute"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For medium input sizes, calculating the factorial recursively is generally faster than the Tower of Hanoi problem due to its linear time complexity compared to exponential time complexity. Tower of Hanoi would require too long to execute.",
      "performance_tips": [
        "Consider memoization for smaller input sizes if the factorial is needed multiple times.",
        "Tail recursion optimization can improve performance, depending on the compiler.",
        "For extremely large n, use iterative approaches or specialized libraries to avoid stack overflow."
      ],
      "trade_offs": [
        "Recursive factorial calculation can lead to stack overflow for large 'n'.",
        "Iterative approaches may be faster for large inputs due to lower overhead.",
        "Space complexity can be significant for deep recursion."
      ]
    }
  ]
]
```
2025-04-01 16:01:12.927 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:12.927 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:14.480 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:14.480 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:17.219 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too long for practical calculation"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the specified input size 'Medium (1000 < n < 100000)', calculating the factorial recursively is significantly more efficient than the Tower of Hanoi. While factorial has a linear time complexity, Tower of Hanoi exhibits an exponential time complexity. Due to extremely long execution time, the Tower of Hanoi calculation is not viable for larger 'n' values.",
      "performance_tips": [
        "Use tail recursion optimization (if the language supports it)",
        "Consider memoization for overlapping subproblems if calculating multiple factorials",
        "Use iterative solution as an alternative to recursive."
      ],
      "trade_offs": [
        "Factorial calculation can lead to stack overflow for very large 'n' without tail recursion optimization or iterative approach.",
        "Recursive solutions can be harder to debug compared to iterative.",
        "The Tower of Hanoi is extremely slow to compute and impractical with recursion for medium input sizes."
      ]
    }
  ]
]
```
2025-04-01 16:01:17.219 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too long for practical calculation"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the specified input size 'Medium (1000 < n < 100000)', calculating the factorial recursively is significantly more efficient than the Tower of Hanoi. While factorial has a linear time complexity, Tower of Hanoi exhibits an exponential time complexity. Due to extremely long execution time, the Tower of Hanoi calculation is not viable for larger 'n' values.",
      "performance_tips": [
        "Use tail recursion optimization (if the language supports it)",
        "Consider memoization for overlapping subproblems if calculating multiple factorials",
        "Use iterative solution as an alternative to recursive."
      ],
      "trade_offs": [
        "Factorial calculation can lead to stack overflow for very large 'n' without tail recursion optimization or iterative approach.",
        "Recursive solutions can be harder to debug compared to iterative.",
        "The Tower of Hanoi is extremely slow to compute and impractical with recursion for medium input sizes."
      ]
    }
  ]
]
```
2025-04-01 16:01:17.219 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:17.219 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:19.955 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:01:19.955 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:01:22.256 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "1.049s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation (Recursive)",
      "insights": "Factorial calculation, even recursively, benefits from the small input size. While both algorithms have O(n) space complexity due to the call stack, the time complexity difference dominates performance. Tower of Hanoi's exponential time complexity makes it significantly slower even for small values of n. For Factorial, the number of operations is directly proportional to n, making it very fast for n < 1000.",
      "performance_tips": [
        "Implement memoization for repeated calls.",
        "Tail recursion optimization can improve performance.",
        "Iterative approach may be slightly faster."
      ],
      "trade_offs": [
        "Recursive calls add overhead.",
        "Stack overflow risk for very large n.",
        "Iterative version may be less readable."
      ]
    }
  ]
]
```
2025-04-01 16:01:22.256 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "1.049s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation (Recursive)",
      "insights": "Factorial calculation, even recursively, benefits from the small input size. While both algorithms have O(n) space complexity due to the call stack, the time complexity difference dominates performance. Tower of Hanoi's exponential time complexity makes it significantly slower even for small values of n. For Factorial, the number of operations is directly proportional to n, making it very fast for n < 1000.",
      "performance_tips": [
        "Implement memoization for repeated calls.",
        "Tail recursion optimization can improve performance.",
        "Iterative approach may be slightly faster."
      ],
      "trade_offs": [
        "Recursive calls add overhead.",
        "Stack overflow risk for very large n.",
        "Iterative version may be less readable."
      ]
    }
  ]
]
```
2025-04-01 16:01:22.256 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:01:22.256 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:01:23.485 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:01:23.485 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:01:25.990 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "4.259s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For smaller values of n (n<1000), factorial calculation boasts significantly faster execution times compared to the Tower of Hanoi. This is primarily due to its linear time complexity O(n), contrasting with the exponential time complexity O(2^n) of Tower of Hanoi. Factorial also uses less space (O(n) due to call stack) than Tower of Hanoi, for larger values of n. The estimated times strongly favor factorial calculation within this small input size range.",
      "performance_tips": [
        "Use memoization to store intermediate results.",
        "Use iterative solution instead of recursion when n becomes large.",
        "Optimize base case check (n <= 1)."
      ],
      "trade_offs": [
        "Overflow risk for larger input values due to the rapid growth of factorials.",
        "Space complexity depends on the maximum recursion depth.",
        "Recursion overhead can be significant for extremely small n."
      ]
    }
  ]
]
```
2025-04-01 16:01:25.990 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "4.259s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For smaller values of n (n<1000), factorial calculation boasts significantly faster execution times compared to the Tower of Hanoi. This is primarily due to its linear time complexity O(n), contrasting with the exponential time complexity O(2^n) of Tower of Hanoi. Factorial also uses less space (O(n) due to call stack) than Tower of Hanoi, for larger values of n. The estimated times strongly favor factorial calculation within this small input size range.",
      "performance_tips": [
        "Use memoization to store intermediate results.",
        "Use iterative solution instead of recursion when n becomes large.",
        "Optimize base case check (n <= 1)."
      ],
      "trade_offs": [
        "Overflow risk for larger input values due to the rapid growth of factorials.",
        "Space complexity depends on the maximum recursion depth.",
        "Recursion overhead can be significant for extremely small n."
      ]
    }
  ]
]
```
2025-04-01 16:01:25.991 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:01:25.991 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:01:28.731 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:28.731 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:31.740 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "overflow"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the given input size (1000 < n < 100000), the Tower of Hanoi calculation becomes computationally infeasible due to its exponential time complexity. The factorial calculation remains within reasonable bounds for this range, despite the recursive calls. Note, however, that even factorial calculation will result in very large numbers, potentially exceeding the maximum representable value for standard data types; for very large values of n, specialized libraries for handling large numbers will be required. The 'overflow' label for Tower of Hanoi indicates this computational impracticality.",
      "performance_tips": [
        "Use memoization to optimize the factorial calculation (though typically not necessary for this range of n).",
        "Consider using an iterative approach instead of recursion for factorial calculation to reduce function call overhead, although the complexity remains O(n).",
        "For very large factorials, explore using libraries that handle arbitrary-precision arithmetic."
      ],
      "trade_offs": [
        "Recursive factorial calculation has a space complexity of O(n) due to the call stack, which could become a limiting factor for extremely large n.",
        "Tower of Hanoi's exponential time complexity makes it impractical for medium to large values of n.",
        "Factorial calculation, even for medium 'n', can lead to integer overflow without proper handling of large numbers."
      ]
    }
  ]
]
```
2025-04-01 16:01:31.740 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "overflow"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the given input size (1000 < n < 100000), the Tower of Hanoi calculation becomes computationally infeasible due to its exponential time complexity. The factorial calculation remains within reasonable bounds for this range, despite the recursive calls. Note, however, that even factorial calculation will result in very large numbers, potentially exceeding the maximum representable value for standard data types; for very large values of n, specialized libraries for handling large numbers will be required. The 'overflow' label for Tower of Hanoi indicates this computational impracticality.",
      "performance_tips": [
        "Use memoization to optimize the factorial calculation (though typically not necessary for this range of n).",
        "Consider using an iterative approach instead of recursion for factorial calculation to reduce function call overhead, although the complexity remains O(n).",
        "For very large factorials, explore using libraries that handle arbitrary-precision arithmetic."
      ],
      "trade_offs": [
        "Recursive factorial calculation has a space complexity of O(n) due to the call stack, which could become a limiting factor for extremely large n.",
        "Tower of Hanoi's exponential time complexity makes it impractical for medium to large values of n.",
        "Factorial calculation, even for medium 'n', can lead to integer overflow without proper handling of large numbers."
      ]
    }
  ]
]
```
2025-04-01 16:01:31.740 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:31.740 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:32.532 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:32.532 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:34.927 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Execution time is too large"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial calculation using recursion is efficient for smaller values of n. Tower of Hanoi, with its exponential time complexity, becomes computationally infeasible for medium-sized n within reasonable time constraints.",
      "performance_tips": [
        "Use memoization techniques for overlapping subproblems.",
        "Consider iterative solution to reduce function call overhead.",
        "Ensure proper error handling for large n, since the value can quickly go out of range of standard data types."
      ],
      "trade_offs": [
        "Factorial calculation can lead to stack overflow for very large n due to deep recursion.",
        "Tower of Hanoi's O(2^n) makes it impractical for n > 20.",
        "Iterative solutions for factorial can sacrifice readability for performance."
      ]
    }
  ]
]
```
2025-04-01 16:01:34.927 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.010s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Execution time is too large"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial calculation using recursion is efficient for smaller values of n. Tower of Hanoi, with its exponential time complexity, becomes computationally infeasible for medium-sized n within reasonable time constraints.",
      "performance_tips": [
        "Use memoization techniques for overlapping subproblems.",
        "Consider iterative solution to reduce function call overhead.",
        "Ensure proper error handling for large n, since the value can quickly go out of range of standard data types."
      ],
      "trade_offs": [
        "Factorial calculation can lead to stack overflow for very large n due to deep recursion.",
        "Tower of Hanoi's O(2^n) makes it impractical for n > 20.",
        "Iterative solutions for factorial can sacrifice readability for performance."
      ]
    }
  ]
]
```
2025-04-01 16:01:34.927 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:34.927 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:39.964 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:01:39.964 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:01:43.117 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "inf"
    }
  ],
  [
    {
      "recommendation": "Avoid Tower of Hanoi for large n",
      "insights": "For a large input size like n = 1,000,000, the Tower of Hanoi problem's exponential time complexity makes it computationally infeasible. Factorial calculation, while O(n), is much more practical. Tower of Hanoi would take significantly longer to compute than the age of the universe. Factorial also will not be easily computable for n = 1,000,000 in normal machines, however, it has much lower complexity and is more practical of the two.",
      "performance_tips": [
        "For factorial, consider memoization for smaller, repeated calculations.",
        "For factorial, use iterative implementation to avoid stack overflow for very large n.",
        "Implement tail-call optimization for Factorial Calculation to minimize the stack space used during recursive calls. Many languages do not support tail-call optimization."
      ],
      "trade_offs": [
        "Factorial calculation's space complexity can be a concern for extremely large 'n' due to stack usage.",
        "Tower of Hanoi's exponential time complexity makes it unusable for large 'n'.",
        "For factorial calculation, very large results require handling of big integers, adding overhead."
      ]
    }
  ]
]
```
2025-04-01 16:01:43.117 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "inf"
    }
  ],
  [
    {
      "recommendation": "Avoid Tower of Hanoi for large n",
      "insights": "For a large input size like n = 1,000,000, the Tower of Hanoi problem's exponential time complexity makes it computationally infeasible. Factorial calculation, while O(n), is much more practical. Tower of Hanoi would take significantly longer to compute than the age of the universe. Factorial also will not be easily computable for n = 1,000,000 in normal machines, however, it has much lower complexity and is more practical of the two.",
      "performance_tips": [
        "For factorial, consider memoization for smaller, repeated calculations.",
        "For factorial, use iterative implementation to avoid stack overflow for very large n.",
        "Implement tail-call optimization for Factorial Calculation to minimize the stack space used during recursive calls. Many languages do not support tail-call optimization."
      ],
      "trade_offs": [
        "Factorial calculation's space complexity can be a concern for extremely large 'n' due to stack usage.",
        "Tower of Hanoi's exponential time complexity makes it unusable for large 'n'.",
        "For factorial calculation, very large results require handling of big integers, adding overhead."
      ]
    }
  ]
]
```
2025-04-01 16:01:43.117 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:01:43.117 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:01:47.277 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:47.277 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:50.072 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "too long to execute"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial calculation has linear time complexity O(n), making it highly efficient for medium-sized inputs (n=10000). Tower of Hanoi has exponential time complexity O(2^n), making it computationally infeasible for n=10000. Its execution time would be prohibitively long, exceeding practical limits for even relatively modest 'n' values. The space complexity of Factorial is O(n), due to the recursive call stack and Tower of Hanoi has O(n).",
      "performance_tips": [
        "Utilize memoization for smaller values if repetitive calculations occur.",
        "Employ iterative approach for factorial calculation to reduce stack overhead.",
        "Consider using a BigInteger library if the factorial result exceeds the maximum value of standard integer types."
      ],
      "trade_offs": [
        "Recursive factorial calculation can lead to stack overflow for very large inputs.",
        "Factorial calculations become computationally expensive even at moderate inputs (n>20) so a more space efficient iterative approach is preferred.",
        "Tower of Hanoi's exponential time complexity makes it impractical for medium to large problem sizes."
      ]
    }
  ]
]
```
2025-04-01 16:01:50.072 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "too long to execute"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial calculation has linear time complexity O(n), making it highly efficient for medium-sized inputs (n=10000). Tower of Hanoi has exponential time complexity O(2^n), making it computationally infeasible for n=10000. Its execution time would be prohibitively long, exceeding practical limits for even relatively modest 'n' values. The space complexity of Factorial is O(n), due to the recursive call stack and Tower of Hanoi has O(n).",
      "performance_tips": [
        "Utilize memoization for smaller values if repetitive calculations occur.",
        "Employ iterative approach for factorial calculation to reduce stack overhead.",
        "Consider using a BigInteger library if the factorial result exceeds the maximum value of standard integer types."
      ],
      "trade_offs": [
        "Recursive factorial calculation can lead to stack overflow for very large inputs.",
        "Factorial calculations become computationally expensive even at moderate inputs (n>20) so a more space efficient iterative approach is preferred.",
        "Tower of Hanoi's exponential time complexity makes it impractical for medium to large problem sizes."
      ]
    }
  ]
]
```
2025-04-01 16:01:50.073 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:50.073 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:01:55.096 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 16:01:55.096 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 16:01:58.068 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 16:01:58.068 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 16:01:58.107 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:01:58.107 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:02:01.286 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000103092s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "infinitys"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the given input size (10,000), calculating the factorial recursively is far more efficient than solving the Tower of Hanoi problem. The time complexity of factorial calculation is linear (O(n)), making it practical for medium-sized inputs. Tower of Hanoi, with its exponential time complexity (O(2^n)), becomes computationally infeasible very quickly. For n = 10,000, 2^n is an astronomically large number, exceeding the capabilities of any standard computer to compute within a reasonable timeframe.",
      "performance_tips": [
        "Implement memoization to store already computed factorial values (if applicable).",
        "Use iterative approach as it usually performs slightly better than the recursive approach because of the overhead associated with function calls in recursion.",
        "Check for overflow conditions as factorials can quickly exceed the maximum representable integer value."
      ],
      "trade_offs": [
        "Recursive factorial calculation has a space complexity of O(n) due to the call stack, but it is manageable for the given input size.",
        "Factorial calculation can lead to integer overflow if the result exceeds the maximum representable value of the chosen data type. Consider using larger data types or arbitrary-precision arithmetic if needed.",
        "The recursive implementation might be less efficient than an iterative implementation due to function call overhead."
      ]
    }
  ]
]
```
2025-04-01 16:02:01.286 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000103092s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "infinitys"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the given input size (10,000), calculating the factorial recursively is far more efficient than solving the Tower of Hanoi problem. The time complexity of factorial calculation is linear (O(n)), making it practical for medium-sized inputs. Tower of Hanoi, with its exponential time complexity (O(2^n)), becomes computationally infeasible very quickly. For n = 10,000, 2^n is an astronomically large number, exceeding the capabilities of any standard computer to compute within a reasonable timeframe.",
      "performance_tips": [
        "Implement memoization to store already computed factorial values (if applicable).",
        "Use iterative approach as it usually performs slightly better than the recursive approach because of the overhead associated with function calls in recursion.",
        "Check for overflow conditions as factorials can quickly exceed the maximum representable integer value."
      ],
      "trade_offs": [
        "Recursive factorial calculation has a space complexity of O(n) due to the call stack, but it is manageable for the given input size.",
        "Factorial calculation can lead to integer overflow if the result exceeds the maximum representable value of the chosen data type. Consider using larger data types or arbitrary-precision arithmetic if needed.",
        "The recursive implementation might be less efficient than an iterative implementation due to function call overhead."
      ]
    }
  ]
]
```
2025-04-01 16:02:01.286 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:02:01.286 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:02:07.430 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:02:07.430 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:02:10.499 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000105637s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.41194336s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For a medium input size (n = 10,000), the factorial calculation is significantly faster than the Tower of Hanoi. The factorial calculation's O(n) time complexity scales linearly, while the Tower of Hanoi's O(2^n) complexity grows exponentially, making it impractical for even moderately sized inputs.",
      "performance_tips": [
        "Implement memoization to avoid redundant calculations if factorial is called multiple times with the same input.",
        "Use tail-call optimization if the programming language supports it to reduce stack usage.",
        "Consider using iterative approach, as iterative solutions are often more efficient than recursive for factorial calculation."
      ],
      "trade_offs": [
        "Factorial calculation requires O(n) space for the call stack when implemented recursively, which can lead to stack overflow errors for very large inputs.",
        "The output of the factorial function grows extremely rapidly, potentially leading to integer overflow issues. Consider using larger data types or arbitrary-precision arithmetic libraries.",
        "While recursion provides a clear and concise solution for factorial, it may not be the most efficient in terms of raw processing speed compared to iterative methods."
      ]
    }
  ]
]
```
2025-04-01 16:02:10.499 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000105637s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.41194336s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For a medium input size (n = 10,000), the factorial calculation is significantly faster than the Tower of Hanoi. The factorial calculation's O(n) time complexity scales linearly, while the Tower of Hanoi's O(2^n) complexity grows exponentially, making it impractical for even moderately sized inputs.",
      "performance_tips": [
        "Implement memoization to avoid redundant calculations if factorial is called multiple times with the same input.",
        "Use tail-call optimization if the programming language supports it to reduce stack usage.",
        "Consider using iterative approach, as iterative solutions are often more efficient than recursive for factorial calculation."
      ],
      "trade_offs": [
        "Factorial calculation requires O(n) space for the call stack when implemented recursively, which can lead to stack overflow errors for very large inputs.",
        "The output of the factorial function grows extremely rapidly, potentially leading to integer overflow issues. Consider using larger data types or arbitrary-precision arithmetic libraries.",
        "While recursion provides a clear and concise solution for factorial, it may not be the most efficient in terms of raw processing speed compared to iterative methods."
      ]
    }
  ]
]
```
2025-04-01 16:02:10.500 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:02:10.500 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:02:14.235 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:02:14.235 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:02:17.362 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000112345s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "inf"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Given a large input size (n > 100000) and only considering recursion-based factorial and Tower of Hanoi, factorial calculation is vastly superior.  While both algorithms use recursion and have space complexity O(n) due to the call stack, the time complexity differs dramatically. Factorial has a linear time complexity O(n) while Tower of Hanoi has an exponential time complexity O(2^n).  For n = 1,000,000, the time to complete Tower of Hanoi recursively is astronomically high (effectively infinite), making factorial the only viable option here. It's important to note that iterative solutions for factorial are generally preferred for performance reasons, but we are constrained to recursive approaches within this category.",
      "performance_tips": [
        "Use memoization where applicable.",
        "Consider tail recursion optimization if supported by the compiler/language.",
        "Ensure sufficient stack space is available to avoid stack overflow errors with deep recursion."
      ],
      "trade_offs": [
        "Recursion can lead to stack overflow errors for very large n.",
        "Recursion often has higher overhead than iterative solutions due to function call overhead.",
        "Space complexity is O(n) due to the call stack, which could be a concern for extremely large n values, though it's more manageable than Tower of Hanoi."
      ]
    }
  ]
]
```
2025-04-01 16:02:17.362 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000112345s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "inf"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Given a large input size (n > 100000) and only considering recursion-based factorial and Tower of Hanoi, factorial calculation is vastly superior.  While both algorithms use recursion and have space complexity O(n) due to the call stack, the time complexity differs dramatically. Factorial has a linear time complexity O(n) while Tower of Hanoi has an exponential time complexity O(2^n).  For n = 1,000,000, the time to complete Tower of Hanoi recursively is astronomically high (effectively infinite), making factorial the only viable option here. It's important to note that iterative solutions for factorial are generally preferred for performance reasons, but we are constrained to recursive approaches within this category.",
      "performance_tips": [
        "Use memoization where applicable.",
        "Consider tail recursion optimization if supported by the compiler/language.",
        "Ensure sufficient stack space is available to avoid stack overflow errors with deep recursion."
      ],
      "trade_offs": [
        "Recursion can lead to stack overflow errors for very large n.",
        "Recursion often has higher overhead than iterative solutions due to function call overhead.",
        "Space complexity is O(n) due to the call stack, which could be a concern for extremely large n values, though it's more manageable than Tower of Hanoi."
      ]
    }
  ]
]
```
2025-04-01 16:02:17.362 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:02:17.362 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:02:18.588 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:02:18.588 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:02:21.311 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000117382s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Inf"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large values of 'n', calculating the factorial using recursion, while conceptually simple, quickly becomes infeasible for Tower of Hanoi. The Tower of Hanoi problem, with its exponential time complexity (O(2^n)), will result in stack overflow errors or extremely long computation times for 'n' greater than 100,000, making Factorial significantly more efficient within the constraints of reasonable time.",
      "performance_tips": [
        "Use tail recursion optimization if the language supports it to potentially reduce stack usage.",
        "Consider memoization techniques to store previously calculated factorial values for improved performance if calculating for multiple values.",
        "If possible switch to iterative implementation to completely avoid recursion overhead."
      ],
      "trade_offs": [
        "Recursion depth can lead to stack overflow errors for very large n in Factorial, although the stack space grows only linearly compared to the exponential requirements of Tower of Hanoi.",
        "Factorial calculations are inherently limited by the maximum representable integer size.",
        "Tower of Hanoi quickly becomes intractable as 'n' increases."
      ]
    }
  ]
]
```
2025-04-01 16:02:21.311 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000117382s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Inf"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large values of 'n', calculating the factorial using recursion, while conceptually simple, quickly becomes infeasible for Tower of Hanoi. The Tower of Hanoi problem, with its exponential time complexity (O(2^n)), will result in stack overflow errors or extremely long computation times for 'n' greater than 100,000, making Factorial significantly more efficient within the constraints of reasonable time.",
      "performance_tips": [
        "Use tail recursion optimization if the language supports it to potentially reduce stack usage.",
        "Consider memoization techniques to store previously calculated factorial values for improved performance if calculating for multiple values.",
        "If possible switch to iterative implementation to completely avoid recursion overhead."
      ],
      "trade_offs": [
        "Recursion depth can lead to stack overflow errors for very large n in Factorial, although the stack space grows only linearly compared to the exponential requirements of Tower of Hanoi.",
        "Factorial calculations are inherently limited by the maximum representable integer size.",
        "Tower of Hanoi quickly becomes intractable as 'n' increases."
      ]
    }
  ]
]
```
2025-04-01 16:02:21.312 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:02:21.312 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:02:23.642 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:02:23.642 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:02:26.525 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000005342s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "1.2676506e+146s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Factorial Calculation",
      "insights": "Factorial calculation, with O(n) time complexity, is significantly more efficient for small 'n' than the Tower of Hanoi, which has O(2^n) time complexity. For n=500, the exponential complexity of Tower of Hanoi makes it completely impractical.",
      "performance_tips": [
        "Use memoization if calculating factorials multiple times with overlapping subproblems.",
        "Utilize tail recursion optimization where possible, although impact will be minimal for small 'n'.",
        "Consider iterative approach for potential marginal performance gain and stack overflow prevention, even for small n."
      ],
      "trade_offs": [
        "Factorial can result in integer overflow for larger inputs, even with small n, requiring appropriate data type handling.",
        "Tower of Hanoi is primarily used for demonstration of recursive principles rather than practical computation for substantial 'n'.",
        "For very small n, the constant overhead of function calls in recursive factorial might become noticeable, though the difference is negligible."
      ]
    }
  ]
]
```
2025-04-01 16:02:26.525 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000005342s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "1.2676506e+146s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Factorial Calculation",
      "insights": "Factorial calculation, with O(n) time complexity, is significantly more efficient for small 'n' than the Tower of Hanoi, which has O(2^n) time complexity. For n=500, the exponential complexity of Tower of Hanoi makes it completely impractical.",
      "performance_tips": [
        "Use memoization if calculating factorials multiple times with overlapping subproblems.",
        "Utilize tail recursion optimization where possible, although impact will be minimal for small 'n'.",
        "Consider iterative approach for potential marginal performance gain and stack overflow prevention, even for small n."
      ],
      "trade_offs": [
        "Factorial can result in integer overflow for larger inputs, even with small n, requiring appropriate data type handling.",
        "Tower of Hanoi is primarily used for demonstration of recursive principles rather than practical computation for substantial 'n'.",
        "For very small n, the constant overhead of function calls in recursive factorial might become noticeable, though the difference is negligible."
      ]
    }
  ]
]
```
2025-04-01 16:02:26.525 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:02:26.525 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:02:32.551 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:02:32.551 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:02:35.457 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0010336s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.52457810584614E+29s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For a large input size (n > 100000), calculating the factorial using recursion becomes significantly more efficient compared to the Tower of Hanoi. Factorial calculation has a linear time complexity, O(n), while the Tower of Hanoi has an exponential time complexity, O(2^n). This results in the Tower of Hanoi calculation taking an astronomically long time to complete for such a large n, making it practically infeasible.",
      "performance_tips": [
        "Use memoization for smaller factorial calculations to avoid redundant computations.",
        "Implement tail recursion optimization where available to minimize stack usage.",
        "Consider iterative approaches to further improve space efficiency, as iterative factorial calculation only requires constant space, O(1)."
      ],
      "trade_offs": [
        "Factorial calculation may still be limited by the maximum recursion depth depending on the programming language.",
        "For extremely large values of 'n', the result may exceed the maximum representable value for standard data types, requiring the use of arbitrary-precision arithmetic libraries.",
        "Recursive factorial calculation consumes more stack space (O(n)) compared to iterative approaches (O(1))."
      ]
    }
  ]
]
```
2025-04-01 16:02:35.457 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0010336s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.52457810584614E+29s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For a large input size (n > 100000), calculating the factorial using recursion becomes significantly more efficient compared to the Tower of Hanoi. Factorial calculation has a linear time complexity, O(n), while the Tower of Hanoi has an exponential time complexity, O(2^n). This results in the Tower of Hanoi calculation taking an astronomically long time to complete for such a large n, making it practically infeasible.",
      "performance_tips": [
        "Use memoization for smaller factorial calculations to avoid redundant computations.",
        "Implement tail recursion optimization where available to minimize stack usage.",
        "Consider iterative approaches to further improve space efficiency, as iterative factorial calculation only requires constant space, O(1)."
      ],
      "trade_offs": [
        "Factorial calculation may still be limited by the maximum recursion depth depending on the programming language.",
        "For extremely large values of 'n', the result may exceed the maximum representable value for standard data types, requiring the use of arbitrary-precision arithmetic libraries.",
        "Recursive factorial calculation consumes more stack space (O(n)) compared to iterative approaches (O(1))."
      ]
    }
  ]
]
```
2025-04-01 16:02:35.457 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:02:35.457 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:02:41.183 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 16:02:41.183 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 16:02:44.982 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0005567s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0004889s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0017492s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.0019871s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: DFS or BFS",
      "insights": "For graph traversal on small graphs (n < 1000), both Depth-First Search (DFS) and Breadth-First Search (BFS) offer similar performance characteristics, with their time complexity being O(V+E). Given the small input size, the logarithmic factors in Dijkstra's and Kruskal's algorithms become relatively more significant, leading to higher execution times. The choice between DFS and BFS largely depends on the specific problem requirements. If the goal is to find a path from a starting node to a target node and the target is likely to be 'shallow' (close to the starting node), BFS might be preferred. If the graph is very deep or contains cycles, DFS might require measures to prevent infinite loops (e.g., marking visited nodes).",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs to reduce memory usage.",
        "Implement iterative versions of DFS to avoid stack overflow issues with very deep graphs.",
        "Optimize memory allocation for visited nodes to reduce overhead."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS for deep graphs.",
        "DFS can be prone to stack overflow for very deep graphs if implemented recursively.",
        "Dijkstra's and Kruskal's are designed for specific problems (shortest path and minimum spanning tree, respectively) and add overhead if simple graph traversal is sufficient."
      ]
    }
  ]
]
```
2025-04-01 16:02:44.982 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0005567s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0004889s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0017492s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.0019871s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: DFS or BFS",
      "insights": "For graph traversal on small graphs (n < 1000), both Depth-First Search (DFS) and Breadth-First Search (BFS) offer similar performance characteristics, with their time complexity being O(V+E). Given the small input size, the logarithmic factors in Dijkstra's and Kruskal's algorithms become relatively more significant, leading to higher execution times. The choice between DFS and BFS largely depends on the specific problem requirements. If the goal is to find a path from a starting node to a target node and the target is likely to be 'shallow' (close to the starting node), BFS might be preferred. If the graph is very deep or contains cycles, DFS might require measures to prevent infinite loops (e.g., marking visited nodes).",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs to reduce memory usage.",
        "Implement iterative versions of DFS to avoid stack overflow issues with very deep graphs.",
        "Optimize memory allocation for visited nodes to reduce overhead."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS for deep graphs.",
        "DFS can be prone to stack overflow for very deep graphs if implemented recursively.",
        "Dijkstra's and Kruskal's are designed for specific problems (shortest path and minimum spanning tree, respectively) and add overhead if simple graph traversal is sufficient."
      ]
    }
  ]
]
```
2025-04-01 16:02:44.982 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 16:02:44.982 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 16:02:46.694 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 16:02:46.694 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 16:02:50.164 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0005421s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0004338s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0019876s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.0023114s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Depth-First Search (DFS) or Breadth-First Search (BFS)",
      "insights": "For small graphs (n < 1000), the choice between DFS and BFS often depends on the specific problem you are solving. Both have a time complexity of O(V + E). DFS tends to use less memory in some scenarios due to its stack-like nature. Dijkstra's and Kruskal's algorithms are more complex and generally used for finding shortest paths or minimum spanning trees, respectively; they aren't general-purpose graph traversal algorithms in the same way as BFS and DFS.",
      "performance_tips": [
        "Choose appropriate data structures (e.g., adjacency list or matrix).",
        "Optimize neighbor access within the graph representation.",
        "Avoid redundant computations by using visited flags."
      ],
      "trade_offs": [
        "DFS can encounter stack overflow issues on very deep graphs (less of a concern for small graphs).",
        "BFS typically uses more memory than DFS, especially if the branching factor is high.",
        "Dijkstra and Kruskal are only appropriate if you need shortest paths or minimum spanning trees."
      ]
    }
  ]
]
```
2025-04-01 16:02:50.164 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0005421s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0004338s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0019876s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.0023114s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Depth-First Search (DFS) or Breadth-First Search (BFS)",
      "insights": "For small graphs (n < 1000), the choice between DFS and BFS often depends on the specific problem you are solving. Both have a time complexity of O(V + E). DFS tends to use less memory in some scenarios due to its stack-like nature. Dijkstra's and Kruskal's algorithms are more complex and generally used for finding shortest paths or minimum spanning trees, respectively; they aren't general-purpose graph traversal algorithms in the same way as BFS and DFS.",
      "performance_tips": [
        "Choose appropriate data structures (e.g., adjacency list or matrix).",
        "Optimize neighbor access within the graph representation.",
        "Avoid redundant computations by using visited flags."
      ],
      "trade_offs": [
        "DFS can encounter stack overflow issues on very deep graphs (less of a concern for small graphs).",
        "BFS typically uses more memory than DFS, especially if the branching factor is high.",
        "Dijkstra and Kruskal are only appropriate if you need shortest paths or minimum spanning trees."
      ]
    }
  ]
]
```
2025-04-01 16:02:50.164 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 16:02:50.164 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 16:02:53.197 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 16:02:53.197 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 16:02:57.331 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0023456789s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0021234567s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E + V log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0241928374s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0362847563s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: BFS or DFS",
      "insights": "For simple graph traversal where finding the shortest path or minimum spanning tree isn't required, BFS and DFS are highly efficient due to their linear time complexity, O(V + E). Given the large input size (n > 100000), Dijkstra's and Kruskal's algorithms incur more overhead due to their logarithmic factors, making them significantly slower for basic traversal. If the graph is very dense (E close to V^2), the difference between O(E) and O(E log E) or O(E + V log V) will be substantial.  BFS is generally preferred for finding the shortest path in unweighted graphs, while DFS is useful for exploring deeply into a graph and for detecting cycles.",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs to reduce memory usage and improve performance.",
        "Optimize memory allocation to avoid frequent dynamic memory operations.",
        "Avoid redundant computations by caching visited nodes."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS due to the queue, especially for wide graphs.",
        "DFS may lead to stack overflow errors for very deep graphs; iterative DFS can mitigate this issue.",
        "Dijkstra’s and Kruskal offer shortest path or minimum spanning tree, sacrificing traversal speed."
      ]
    }
  ]
]
```
2025-04-01 16:02:57.331 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0023456789s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0021234567s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E + V log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0241928374s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0362847563s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: BFS or DFS",
      "insights": "For simple graph traversal where finding the shortest path or minimum spanning tree isn't required, BFS and DFS are highly efficient due to their linear time complexity, O(V + E). Given the large input size (n > 100000), Dijkstra's and Kruskal's algorithms incur more overhead due to their logarithmic factors, making them significantly slower for basic traversal. If the graph is very dense (E close to V^2), the difference between O(E) and O(E log E) or O(E + V log V) will be substantial.  BFS is generally preferred for finding the shortest path in unweighted graphs, while DFS is useful for exploring deeply into a graph and for detecting cycles.",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs to reduce memory usage and improve performance.",
        "Optimize memory allocation to avoid frequent dynamic memory operations.",
        "Avoid redundant computations by caching visited nodes."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS due to the queue, especially for wide graphs.",
        "DFS may lead to stack overflow errors for very deep graphs; iterative DFS can mitigate this issue.",
        "Dijkstra’s and Kruskal offer shortest path or minimum spanning tree, sacrificing traversal speed."
      ]
    }
  ]
]
```
2025-04-01 16:02:57.332 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 16:02:57.332 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 16:03:04.118 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:03:04.118 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:03:09.075 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.021345678s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.018765432s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.046913579s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.058123456s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Depth-First Search (DFS) or Breadth-First Search (BFS)",
      "insights": "For graph traversal in a medium-sized graph, both DFS and BFS offer comparable performance with O(V+E) time complexity. The choice between DFS and BFS depends on the specific application. If the target node is expected to be close to the starting node, BFS might be faster. If the graph has deep branches, DFS might be more memory-efficient due to its stack-like nature. For finding shortest paths Dijkstra's is preferred for weighted graphs, but its higher time complexity of O(E log V) becomes noticeable. Kruskal's algorithm, used for finding the Minimum Spanning Tree (MST), has the highest time complexity of O(E log E), making it less suitable for general graph traversal unless an MST is specifically needed.  The execution times given are estimated, and the actual performance will depend on graph density and implementation details.  For a graph with 10,000 nodes and a moderate number of edges (e.g., 20,000 edges), O(V+E) translates to around 30,000 operations.  O(E log V) for Dijkstra's equates to roughly 20,000 * log(10,000) ≈ 80,000 operations and Kruskal’s approximately 100,000 operations (20000 * log(20000)).",
      "performance_tips": [
        "Use adjacency lists to represent graphs efficiently, especially for sparse graphs.",
        "Optimize data structures for priority queues in Dijkstra's algorithm (e.g., Fibonacci heaps, binary heaps).",
        "For DFS, consider iterative implementation to avoid stack overflow issues with very deep graphs."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS due to the queue, potentially leading to out-of-memory issues on very large graphs.",
        "Dijkstra's algorithm only works with non-negative edge weights.",
        "Kruskal's algorithm is specifically for finding MSTs, not general graph traversal."
      ]
    }
  ]
]
```
2025-04-01 16:03:09.075 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.021345678s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.018765432s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.046913579s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.058123456s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Depth-First Search (DFS) or Breadth-First Search (BFS)",
      "insights": "For graph traversal in a medium-sized graph, both DFS and BFS offer comparable performance with O(V+E) time complexity. The choice between DFS and BFS depends on the specific application. If the target node is expected to be close to the starting node, BFS might be faster. If the graph has deep branches, DFS might be more memory-efficient due to its stack-like nature. For finding shortest paths Dijkstra's is preferred for weighted graphs, but its higher time complexity of O(E log V) becomes noticeable. Kruskal's algorithm, used for finding the Minimum Spanning Tree (MST), has the highest time complexity of O(E log E), making it less suitable for general graph traversal unless an MST is specifically needed.  The execution times given are estimated, and the actual performance will depend on graph density and implementation details.  For a graph with 10,000 nodes and a moderate number of edges (e.g., 20,000 edges), O(V+E) translates to around 30,000 operations.  O(E log V) for Dijkstra's equates to roughly 20,000 * log(10,000) ≈ 80,000 operations and Kruskal’s approximately 100,000 operations (20000 * log(20000)).",
      "performance_tips": [
        "Use adjacency lists to represent graphs efficiently, especially for sparse graphs.",
        "Optimize data structures for priority queues in Dijkstra's algorithm (e.g., Fibonacci heaps, binary heaps).",
        "For DFS, consider iterative implementation to avoid stack overflow issues with very deep graphs."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS due to the queue, potentially leading to out-of-memory issues on very large graphs.",
        "Dijkstra's algorithm only works with non-negative edge weights.",
        "Kruskal's algorithm is specifically for finding MSTs, not general graph traversal."
      ]
    }
  ]
]
```
2025-04-01 16:03:09.076 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:03:09.076 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:06.497 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:06:06.497 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:06:10.334 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000020491s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000017485s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000106071s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000138887s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Depth-First Search (DFS) or Breadth-First Search (BFS)",
      "insights": "For a medium-sized graph (1000 < n < 100000), both DFS and BFS are often suitable choices for basic graph traversal. Their O(V + E) time complexity makes them efficient for exploring all vertices and edges. However, if the goal is to find the shortest path between two nodes in an unweighted graph, BFS is generally preferred. If the goal is to explore deeply into the graph before backtracking, DFS is often a more natural fit. Dijkstra's and Kruskal's algorithms are designed for more specific tasks (shortest path in a weighted graph and minimum spanning tree, respectively) and have higher time complexities, making them less suitable for general traversal when other factors are equal.",
      "performance_tips": [
        "Use appropriate data structures for graph representation (adjacency list is generally more efficient for sparse graphs).",
        "Avoid redundant calculations by marking visited nodes.",
        "Optimize the order in which neighbors are explored based on the specific problem."
      ],
      "trade_offs": [
        "DFS can lead to stack overflow for very deep graphs without proper handling.",
        "BFS requires more memory than DFS for wide graphs.",
        "Dijkstra's and Kruskal's are less versatile for basic traversal compared to BFS and DFS."
      ]
    }
  ]
]
```
2025-04-01 16:06:10.334 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000020491s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000017485s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000106071s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000138887s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: Depth-First Search (DFS) or Breadth-First Search (BFS)",
      "insights": "For a medium-sized graph (1000 < n < 100000), both DFS and BFS are often suitable choices for basic graph traversal. Their O(V + E) time complexity makes them efficient for exploring all vertices and edges. However, if the goal is to find the shortest path between two nodes in an unweighted graph, BFS is generally preferred. If the goal is to explore deeply into the graph before backtracking, DFS is often a more natural fit. Dijkstra's and Kruskal's algorithms are designed for more specific tasks (shortest path in a weighted graph and minimum spanning tree, respectively) and have higher time complexities, making them less suitable for general traversal when other factors are equal.",
      "performance_tips": [
        "Use appropriate data structures for graph representation (adjacency list is generally more efficient for sparse graphs).",
        "Avoid redundant calculations by marking visited nodes.",
        "Optimize the order in which neighbors are explored based on the specific problem."
      ],
      "trade_offs": [
        "DFS can lead to stack overflow for very deep graphs without proper handling.",
        "BFS requires more memory than DFS for wide graphs.",
        "Dijkstra's and Kruskal's are less versatile for basic traversal compared to BFS and DFS."
      ]
    }
  ]
]
```
2025-04-01 16:06:10.334 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:10.334 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:13.058 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:06:13.058 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:06:17.023 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.020742158s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.017185442s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.054630368s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.067932357s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: DFS or BFS",
      "insights": "For medium-sized graphs (1000 < n < 100000), both DFS and BFS offer similar time complexities (O(V+E)). However, the choice between DFS and BFS depends on the specific problem. If the goal is to find the shortest path in an unweighted graph, BFS is preferred. If the goal is to explore the graph deeply or find connected components, DFS might be a better choice. Dijkstra's and Kruskal are suitable for weighted graphs to find shortest paths and Minimum Spanning Trees respectively, however, they have higher time complexities of O(E log V) and O(E log E) making them less efficient for basic graph traversal.",
      "performance_tips": [
        "Use adjacency lists instead of adjacency matrices for sparse graphs to reduce space complexity.",
        "Optimize data structures for queue/stack operations in BFS/DFS.",
        "For Dijkstra, use a priority queue implementation (e.g., a binary heap) for efficient retrieval of the minimum distance vertex."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS in some scenarios due to storing the queue.",
        "DFS can potentially lead to stack overflow errors for very deep graphs.",
        "Dijkstra's and Kruskal's are only applicable to weighted graphs and incur logarithmic overhead."
      ]
    }
  ]
]
```
2025-04-01 16:06:17.023 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.020742158s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.017185442s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.054630368s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.067932357s"
    }
  ],
  [
    {
      "recommendation": "Recommended Algorithm: DFS or BFS",
      "insights": "For medium-sized graphs (1000 < n < 100000), both DFS and BFS offer similar time complexities (O(V+E)). However, the choice between DFS and BFS depends on the specific problem. If the goal is to find the shortest path in an unweighted graph, BFS is preferred. If the goal is to explore the graph deeply or find connected components, DFS might be a better choice. Dijkstra's and Kruskal are suitable for weighted graphs to find shortest paths and Minimum Spanning Trees respectively, however, they have higher time complexities of O(E log V) and O(E log E) making them less efficient for basic graph traversal.",
      "performance_tips": [
        "Use adjacency lists instead of adjacency matrices for sparse graphs to reduce space complexity.",
        "Optimize data structures for queue/stack operations in BFS/DFS.",
        "For Dijkstra, use a priority queue implementation (e.g., a binary heap) for efficient retrieval of the minimum distance vertex."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS in some scenarios due to storing the queue.",
        "DFS can potentially lead to stack overflow errors for very deep graphs.",
        "Dijkstra's and Kruskal's are only applicable to weighted graphs and incur logarithmic overhead."
      ]
    }
  ]
]
```
2025-04-01 16:06:17.023 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:17.023 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:22.046 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 16:06:22.046 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 16:06:27.799 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 16:06:27.799 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-01 16:06:30.645 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:06:30.645 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:06:35.289 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000024334s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000020456s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000108765s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000115987s"
    }
  ],
  [
    {
      "recommendation": "BFS and DFS",
      "insights": "For basic graph traversal, both BFS and DFS offer comparable performance given their O(V+E) time complexity. For a graph with V = 10,000 and assuming E is roughly 2V, the execution times are similar. BFS is generally preferred for finding the shortest path in unweighted graphs, while DFS is better for exploring deeper into the graph or finding connected components. Dijkstra's and Kruskal's algorithms are considerably slower due to their higher time complexities O(E log V) and O(E log E) respectively and are designed for specific problems involving weighted graphs. These are not suitable for basic graph traversal.",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs.",
        "Optimize memory allocation for large graphs.",
        "Consider iterative implementations to avoid stack overflow issues with DFS for very deep graphs."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS due to the queue.",
        "DFS can lead to stack overflow for very deep graphs.",
        "Dijkstra's and Kruskal's are slower for simple traversal but necessary for weighted graph problems."
      ]
    }
  ]
]
```
2025-04-01 16:06:35.289 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000024334s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000020456s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000108765s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000115987s"
    }
  ],
  [
    {
      "recommendation": "BFS and DFS",
      "insights": "For basic graph traversal, both BFS and DFS offer comparable performance given their O(V+E) time complexity. For a graph with V = 10,000 and assuming E is roughly 2V, the execution times are similar. BFS is generally preferred for finding the shortest path in unweighted graphs, while DFS is better for exploring deeper into the graph or finding connected components. Dijkstra's and Kruskal's algorithms are considerably slower due to their higher time complexities O(E log V) and O(E log E) respectively and are designed for specific problems involving weighted graphs. These are not suitable for basic graph traversal.",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs.",
        "Optimize memory allocation for large graphs.",
        "Consider iterative implementations to avoid stack overflow issues with DFS for very deep graphs."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS due to the queue.",
        "DFS can lead to stack overflow for very deep graphs.",
        "Dijkstra's and Kruskal's are slower for simple traversal but necessary for weighted graph problems."
      ]
    }
  ]
]
```
2025-04-01 16:06:35.289 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:35.289 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:39.856 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:06:39.856 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Medium (1000 < n < 100000)
2025-04-01 16:06:43.988 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000024523s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000021423s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000103776s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000113889s"
    }
  ],
  [
    {
      "recommendation": "BFS and DFS",
      "insights": "For simple graph traversal where finding any path is sufficient, both BFS and DFS are strong contenders due to their linear time complexity O(V+E).  The choice between them depends on the specific problem. If the shortest path in an unweighted graph is needed, BFS is preferred. DFS might be more suitable for problems involving exploring deeper into the graph first. Dijkstra's and Kruskal's algorithms are specialized for finding shortest paths in weighted graphs or minimum spanning trees, and their higher time complexities (O(E log V) and O(E log E) respectively) make them less suitable for general traversal in unweighted graphs.",
      "performance_tips": [
        "Use adjacency lists for graph representation to optimize space usage.",
        "Implement iterative versions of DFS to avoid stack overflow for very deep graphs.",
        "Optimize priority queue implementation in Dijkstra's algorithm for faster performance."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS for large graphs because it stores all nodes at a given level.",
        "DFS can lead to stack overflow for deep graphs if implemented recursively.",
        "Dijkstra's and Kruskal's are not suitable for unweighted graphs or simple reachability problems due to higher overhead."
      ]
    }
  ]
]
```
2025-04-01 16:06:43.988 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000024523s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000021423s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000103776s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000113889s"
    }
  ],
  [
    {
      "recommendation": "BFS and DFS",
      "insights": "For simple graph traversal where finding any path is sufficient, both BFS and DFS are strong contenders due to their linear time complexity O(V+E).  The choice between them depends on the specific problem. If the shortest path in an unweighted graph is needed, BFS is preferred. DFS might be more suitable for problems involving exploring deeper into the graph first. Dijkstra's and Kruskal's algorithms are specialized for finding shortest paths in weighted graphs or minimum spanning trees, and their higher time complexities (O(E log V) and O(E log E) respectively) make them less suitable for general traversal in unweighted graphs.",
      "performance_tips": [
        "Use adjacency lists for graph representation to optimize space usage.",
        "Implement iterative versions of DFS to avoid stack overflow for very deep graphs.",
        "Optimize priority queue implementation in Dijkstra's algorithm for faster performance."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS for large graphs because it stores all nodes at a given level.",
        "DFS can lead to stack overflow for deep graphs if implemented recursively.",
        "Dijkstra's and Kruskal's are not suitable for unweighted graphs or simple reachability problems due to higher overhead."
      ]
    }
  ]
]
```
2025-04-01 16:06:43.988 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:43.988 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_t...
2025-04-01 16:06:51.387 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 16:06:51.387 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 16:06:54.767 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001087174s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000987321s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002763214s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002971112s"
    }
  ],
  [
    {
      "recommendation": "DFS and BFS",
      "insights": "For small graphs (n < 1000), the constant factors in the complexity of BFS and DFS become more significant. BFS and DFS offer similar performance for this graph size, with execution times in the sub-millisecond range. Dijkstra's and Kruskal's algorithms have larger overhead due to the priority queue operations (Dijkstra's) and sorting edges (Kruskal's), making BFS and DFS more efficient for simple traversal tasks on small graphs.",
      "performance_tips": [
        "Optimize graph representation (adjacency list vs. matrix).",
        "Avoid redundant node visits.",
        "Choose the appropriate data structure for the queue (BFS) or stack (DFS)."
      ],
      "trade_offs": [
        "BFS finds the shortest path in unweighted graphs; DFS does not.",
        "DFS can get stuck in infinite loops if not implemented carefully; BFS is less prone to this.",
        "Space complexity might be higher for BFS on certain graph structures."
      ]
    }
  ]
]
```
2025-04-01 16:06:54.767 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.001087174s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000987321s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002763214s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002971112s"
    }
  ],
  [
    {
      "recommendation": "DFS and BFS",
      "insights": "For small graphs (n < 1000), the constant factors in the complexity of BFS and DFS become more significant. BFS and DFS offer similar performance for this graph size, with execution times in the sub-millisecond range. Dijkstra's and Kruskal's algorithms have larger overhead due to the priority queue operations (Dijkstra's) and sorting edges (Kruskal's), making BFS and DFS more efficient for simple traversal tasks on small graphs.",
      "performance_tips": [
        "Optimize graph representation (adjacency list vs. matrix).",
        "Avoid redundant node visits.",
        "Choose the appropriate data structure for the queue (BFS) or stack (DFS)."
      ],
      "trade_offs": [
        "BFS finds the shortest path in unweighted graphs; DFS does not.",
        "DFS can get stuck in infinite loops if not implemented carefully; BFS is less prone to this.",
        "Space complexity might be higher for BFS on certain graph structures."
      ]
    }
  ]
]
```
2025-04-01 16:06:54.767 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 16:06:54.767 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 16:06:57.625 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 16:06:57.625 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 16:07:00.139 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000005234s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000831s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a small, sorted dataset (n < 1000), Binary Search offers significantly better performance due to its logarithmic time complexity, assuming the data is already sorted. If the data is unsorted, the initial sorting step must be considered, and Linear Search might be more efficient for a single search. Binary search only searches sorted arrays.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid potential stack overflow issues for very large datasets (although unlikely for n<1000).",
        "Pre-sort the data for multiple searches."
      ],
      "trade_offs": [
        "Requires the input data to be sorted.",
        "Less efficient than linear search for unsorted data if only searching once.",
        "Only applicable when the data can be sorted."
      ]
    }
  ]
]
```
2025-04-01 16:07:00.139 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000005234s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000831s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a small, sorted dataset (n < 1000), Binary Search offers significantly better performance due to its logarithmic time complexity, assuming the data is already sorted. If the data is unsorted, the initial sorting step must be considered, and Linear Search might be more efficient for a single search. Binary search only searches sorted arrays.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid potential stack overflow issues for very large datasets (although unlikely for n<1000).",
        "Pre-sort the data for multiple searches."
      ],
      "trade_offs": [
        "Requires the input data to be sorted.",
        "Less efficient than linear search for unsorted data if only searching once.",
        "Only applicable when the data can be sorted."
      ]
    }
  ]
]
```
2025-04-01 16:07:00.139 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000005234...
2025-04-01 16:07:00.139 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000005234...
2025-04-01 16:07:03.649 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:07:03.649 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:07:06.257 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000117775s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000103743s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium input size (1000 < n < 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity, assuming the data is sorted. Binary Search has a time complexity of O(log n), which translates to fewer operations compared to Linear Search's O(n) complexity. The space complexity for both algorithms is O(1).",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative implementation of Binary Search to avoid potential stack overflow issues for very large input sizes.",
        "Optimize the comparison operation within the Binary Search loop for maximum performance."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Only works on sorted data.",
        "Can be more complex to implement correctly than Linear Search."
      ]
    }
  ]
]
```
2025-04-01 16:07:06.257 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000117775s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000103743s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium input size (1000 < n < 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity, assuming the data is sorted. Binary Search has a time complexity of O(log n), which translates to fewer operations compared to Linear Search's O(n) complexity. The space complexity for both algorithms is O(1).",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative implementation of Binary Search to avoid potential stack overflow issues for very large input sizes.",
        "Optimize the comparison operation within the Binary Search loop for maximum performance."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Only works on sorted data.",
        "Can be more complex to implement correctly than Linear Search."
      ]
    }
  ]
]
```
2025-04-01 16:07:06.257 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:07:06.257 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:07:09.861 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 16:07:09.861 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 16:07:12.045 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001135773s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002274s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "Based on your input size, Binary Search performs significantly better than Linear Search. Binary search has a time complexity of O(log n) compared to O(n) for Linear Search, resulting in orders of magnitude faster execution for large datasets.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead.",
        "Profile the search to identify any hotspots in your data."
      ],
      "trade_offs": [
        "Requires the data to be sorted.",
        "Only applicable for sorted data structures.",
        "Less efficient than Linear Search for very small unsorted datasets."
      ]
    }
  ]
]
```
2025-04-01 16:07:12.045 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001135773s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002274s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "Based on your input size, Binary Search performs significantly better than Linear Search. Binary search has a time complexity of O(log n) compared to O(n) for Linear Search, resulting in orders of magnitude faster execution for large datasets.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead.",
        "Profile the search to identify any hotspots in your data."
      ],
      "trade_offs": [
        "Requires the data to be sorted.",
        "Only applicable for sorted data structures.",
        "Less efficient than Linear Search for very small unsorted datasets."
      ]
    }
  ]
]
```
2025-04-01 16:07:12.045 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00113577...
2025-04-01 16:07:12.045 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00113577...
2025-04-01 16:07:16.070 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:07:16.070 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:07:19.433 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0199237s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0138492s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0160000s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:07:19.433 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0199237s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0138492s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0160000s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:07:19.433 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-01 16:07:19.433 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-01 16:07:32.387 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:07:32.387 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:07:36.016 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1136855669s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001074254s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0969979635s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0810993541s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0000932111s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001131988s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:07:36.016 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1136855669s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0001074254s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0969979635s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0810993541s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0000932111s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0001131988s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:07:36.016 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:07:36.016 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:07:39.827 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:07:39.827 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:07:43.245 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2563291s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0041184s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2538215s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1270037s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0029932s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0036007s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:07:43.245 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2563291s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0041184s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2538215s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1270037s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0029932s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0036007s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:07:43.245 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2563291s"
...
2025-04-01 16:07:43.245 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2563291s"
...
2025-04-01 16:07:54.076 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:07:54.076 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:07:57.417 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.019979424s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.018361152s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.021556416s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:07:57.417 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.019979424s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.018361152s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.021556416s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:07:57.417 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-01 16:07:57.417 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-01 16:08:05.042 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:08:05.042 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:08:08.485 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247813856s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004373744s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.259316944s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.138428368s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.003660848s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.004117696s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:08:08.485 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247813856s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004373744s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.259316944s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.138428368s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.003660848s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.004117696s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:08:08.486 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247813856s...
2025-04-01 16:08:08.486 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247813856s...
2025-04-01 16:08:30.524 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:08:30.524 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:08:32.912 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001123456s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too large to compute practically for n=100000"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial Calculation exhibits a linear time complexity, making it efficient even for large input sizes. Tower of Hanoi's exponential complexity renders it impractical for n > 100000.",
      "performance_tips": [
        "Use memoization techniques if calculating factorials repeatedly.",
        "For very large numbers, use libraries that support arbitrary-precision arithmetic.",
        "Ensure adequate stack size to prevent stack overflow."
      ],
      "trade_offs": [
        "Factorial can result in very large numbers quickly, exceeding standard integer limits.",
        "Recursive implementations can lead to stack overflow errors for very large 'n'.",
        "Tower of Hanoi's exponential nature makes it unsuitable for large inputs."
      ]
    }
  ]
]
```
2025-04-01 16:08:32.912 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001123456s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "Too large to compute practically for n=100000"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial Calculation exhibits a linear time complexity, making it efficient even for large input sizes. Tower of Hanoi's exponential complexity renders it impractical for n > 100000.",
      "performance_tips": [
        "Use memoization techniques if calculating factorials repeatedly.",
        "For very large numbers, use libraries that support arbitrary-precision arithmetic.",
        "Ensure adequate stack size to prevent stack overflow."
      ],
      "trade_offs": [
        "Factorial can result in very large numbers quickly, exceeding standard integer limits.",
        "Recursive implementations can lead to stack overflow errors for very large 'n'.",
        "Tower of Hanoi's exponential nature makes it unsuitable for large inputs."
      ]
    }
  ]
]
```
2025-04-01 16:08:32.912 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:08:32.912 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:08:34.703 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:08:34.703 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:08:37.419 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001082141s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.583927e+30s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial Calculation has a linear time complexity O(n) and is significantly faster than Tower of Hanoi which has exponential time complexity O(2^n) for large input sizes. Tower of Hanoi becomes computationally infeasible even for moderately large n due to its exponential nature.",
      "performance_tips": [
        "Use iterative approach where possible.",
        "Employ memoization if calculating multiple factorials.",
        "Consider approximate methods for very large numbers."
      ],
      "trade_offs": [
        "Space complexity O(n) due to recursion depth.",
        "Limited by maximum recursion depth in some environments.",
        "Can lead to integer overflow for large n, requiring arbitrary-precision arithmetic."
      ]
    }
  ]
]
```
2025-04-01 16:08:37.419 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001082141s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.583927e+30s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial Calculation has a linear time complexity O(n) and is significantly faster than Tower of Hanoi which has exponential time complexity O(2^n) for large input sizes. Tower of Hanoi becomes computationally infeasible even for moderately large n due to its exponential nature.",
      "performance_tips": [
        "Use iterative approach where possible.",
        "Employ memoization if calculating multiple factorials.",
        "Consider approximate methods for very large numbers."
      ],
      "trade_offs": [
        "Space complexity O(n) due to recursion depth.",
        "Limited by maximum recursion depth in some environments.",
        "Can lead to integer overflow for large n, requiring arbitrary-precision arithmetic."
      ]
    }
  ]
]
```
2025-04-01 16:08:37.419 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:08:37.419 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:08:43.686 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:08:43.686 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:08:46.425 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000011234s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.66489e+29s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the given input size, factorial calculation using recursion has a linear time complexity O(n) and uses stack space proportional to n for the recursive calls. Tower of Hanoi, on the other hand, has an exponential time complexity O(2^n), making it extremely inefficient for medium to large input sizes. As n increases in 'Tower of Hanoi', the execution time rapidly becomes astronomically large, rendering it impractical.  Factorial calculation performs best with O(n) average time complexity and minimal space usage (O(n)).",
      "performance_tips": [
        "Use tail recursion optimization where applicable to reduce stack usage.",
        "Memoize results for smaller values to avoid redundant calculations.",
        "Iterative approach to factorial calculation can be more space-efficient."
      ],
      "trade_offs": [
        "Recursive factorial can lead to stack overflow for very large n.",
        "Tower of Hanoi's exponential time complexity makes it unsuitable for practical problems with moderately sized input.",
        "Recursion may introduce overhead compared to iterative solutions."
      ]
    }
  ]
]
```
2025-04-01 16:08:46.425 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000011234s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.66489e+29s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For the given input size, factorial calculation using recursion has a linear time complexity O(n) and uses stack space proportional to n for the recursive calls. Tower of Hanoi, on the other hand, has an exponential time complexity O(2^n), making it extremely inefficient for medium to large input sizes. As n increases in 'Tower of Hanoi', the execution time rapidly becomes astronomically large, rendering it impractical.  Factorial calculation performs best with O(n) average time complexity and minimal space usage (O(n)).",
      "performance_tips": [
        "Use tail recursion optimization where applicable to reduce stack usage.",
        "Memoize results for smaller values to avoid redundant calculations.",
        "Iterative approach to factorial calculation can be more space-efficient."
      ],
      "trade_offs": [
        "Recursive factorial can lead to stack overflow for very large n.",
        "Tower of Hanoi's exponential time complexity makes it unsuitable for practical problems with moderately sized input.",
        "Recursion may introduce overhead compared to iterative solutions."
      ]
    }
  ]
]
```
2025-04-01 16:08:46.426 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:08:46.426 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_secon...
2025-04-01 16:08:51.033 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:08:51.033 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:08:53.567 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000005213s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "4.1125e+142s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Based on the input size and requirements, Factorial Calculation is significantly faster. While both algorithms are recursive, the Tower of Hanoi has an exponential time complexity O(2^n), making it impractical for larger 'n' compared to Factorial's O(n) time complexity.",
      "performance_tips": [
        "Utilize tail recursion optimization (if supported by the language) to reduce stack usage.",
        "Implement memoization if the factorial function will be called multiple times with the same input.",
        "Use iterative approach for slightly better performance than recursion."
      ],
      "trade_offs": [
        "Space complexity of O(n) due to the call stack (can be improved with tail recursion).",
        "Can lead to stack overflow errors for very large values of 'n' without tail recursion optimization.",
        "Limited applicability compared to the Tower of Hanoi."
      ]
    }
  ]
]
```
2025-04-01 16:08:53.567 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000005213s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "4.1125e+142s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Based on the input size and requirements, Factorial Calculation is significantly faster. While both algorithms are recursive, the Tower of Hanoi has an exponential time complexity O(2^n), making it impractical for larger 'n' compared to Factorial's O(n) time complexity.",
      "performance_tips": [
        "Utilize tail recursion optimization (if supported by the language) to reduce stack usage.",
        "Implement memoization if the factorial function will be called multiple times with the same input.",
        "Use iterative approach for slightly better performance than recursion."
      ],
      "trade_offs": [
        "Space complexity of O(n) due to the call stack (can be improved with tail recursion).",
        "Can lead to stack overflow errors for very large values of 'n' without tail recursion optimization.",
        "Limited applicability compared to the Tower of Hanoi."
      ]
    }
  ]
]
```
2025-04-01 16:08:53.567 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:08:53.567 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:08:56.861 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:08:56.861 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:08:59.604 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001051352s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.45387645322345E+29s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, Factorial Calculation via recursion is significantly more efficient than Tower of Hanoi due to its linear time complexity O(n) compared to Tower of Hanoi's exponential time complexity O(2^n).  Tower of Hanoi becomes computationally infeasible for n > 100,000.  The space complexity is O(n) for both algorithms, but the difference in time complexity makes Factorial the clear choice.",
      "performance_tips": [
        "Implement memoization to store previously computed factorial values.",
        "Utilize tail-call optimization if supported by the programming language/compiler.",
        "Consider an iterative implementation for reduced overhead."
      ],
      "trade_offs": [
        "Space complexity is O(n), which can be significant for very large n.",
        "Stack overflow can occur with deep recursion if tail-call optimization is not available.",
        "Iterative implementations might be slightly faster due to reduced function call overhead."
      ]
    }
  ]
]
```
2025-04-01 16:08:59.604 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001051352s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.45387645322345E+29s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, Factorial Calculation via recursion is significantly more efficient than Tower of Hanoi due to its linear time complexity O(n) compared to Tower of Hanoi's exponential time complexity O(2^n).  Tower of Hanoi becomes computationally infeasible for n > 100,000.  The space complexity is O(n) for both algorithms, but the difference in time complexity makes Factorial the clear choice.",
      "performance_tips": [
        "Implement memoization to store previously computed factorial values.",
        "Utilize tail-call optimization if supported by the programming language/compiler.",
        "Consider an iterative implementation for reduced overhead."
      ],
      "trade_offs": [
        "Space complexity is O(n), which can be significant for very large n.",
        "Stack overflow can occur with deep recursion if tail-call optimization is not available.",
        "Iterative implementations might be slightly faster due to reduced function call overhead."
      ]
    }
  ]
]
```
2025-04-01 16:08:59.604 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:08:59.604 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:09:04.709 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:09:04.709 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:09:08.053 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0112345s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0203581s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0078901s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0023456s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0147891s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0185234s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:09:08.053 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0112345s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0203581s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0078901s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0023456s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0147891s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0185234s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:09:08.053 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.01123...
2025-04-01 16:09:08.053 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.01123...
2025-04-01 16:10:18.622 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:10:18.622 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:10:21.999 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2539456s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0041325s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2515398s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1283453s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0031542s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0040876s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:10:21.999 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2539456s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0041325s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2515398s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1283453s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0031542s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0040876s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:10:21.999 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2539456s"
...
2025-04-01 16:10:21.999 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2539456s"
...
2025-04-01 16:10:25.177 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:10:25.177 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:10:29.383 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0128263s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.019293232s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0892839s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.171133s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.016771298s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.017975212s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort, Heap Sort, Merge Sort",
      "insights": "Based on your input size and requirements, Quick Sort, Heap Sort, and Merge Sort are significantly better than the other algorithms. They all have an average time complexity of O(n log n), and showed superior performance in benchmarks for the given dataset size. Considering space complexity and typical practical performance, these three are generally the best choices for large datasets. Quick Sort generally outperforms Merge Sort and Heap Sort in practice but worst-case time complexity is quadratic. Heap sort and Merge Sort are guaranteed O(n log n) time complexity.",
      "performance_tips": [
        "Consider pivot selection strategy (Quick Sort).",
        "Implement tail-call optimization or switch to iterative approach to avoid stack overflow (Merge Sort and Quick Sort).",
        "Use insertion sort for small subarrays (Quick Sort)."
      ],
      "trade_offs": [
        "Quick Sort: Not a stable sorting algorithm, worst-case O(n^2) time complexity is possible, performance highly depends on pivot choice.",
        "Merge Sort: Requires O(n) auxiliary space, slightly slower than Quick Sort in practice.",
        "Heap Sort: Not a stable sorting algorithm, performs slightly worse than quicksort on average."
      ]
    }
  ]
]
```
2025-04-01 16:10:29.383 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0128263s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.019293232s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0892839s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.171133s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.016771298s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.017975212s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort, Heap Sort, Merge Sort",
      "insights": "Based on your input size and requirements, Quick Sort, Heap Sort, and Merge Sort are significantly better than the other algorithms. They all have an average time complexity of O(n log n), and showed superior performance in benchmarks for the given dataset size. Considering space complexity and typical practical performance, these three are generally the best choices for large datasets. Quick Sort generally outperforms Merge Sort and Heap Sort in practice but worst-case time complexity is quadratic. Heap sort and Merge Sort are guaranteed O(n log n) time complexity.",
      "performance_tips": [
        "Consider pivot selection strategy (Quick Sort).",
        "Implement tail-call optimization or switch to iterative approach to avoid stack overflow (Merge Sort and Quick Sort).",
        "Use insertion sort for small subarrays (Quick Sort)."
      ],
      "trade_offs": [
        "Quick Sort: Not a stable sorting algorithm, worst-case O(n^2) time complexity is possible, performance highly depends on pivot choice.",
        "Merge Sort: Requires O(n) auxiliary space, slightly slower than Quick Sort in practice.",
        "Heap Sort: Not a stable sorting algorithm, performs slightly worse than quicksort on average."
      ]
    }
  ]
]
```
2025-04-01 16:10:29.383 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.01282...
2025-04-01 16:10:29.383 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.01282...
2025-04-01 16:10:33.895 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 16:10:33.895 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 16:10:36.234 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001138459s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002066s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "Binary Search offers significantly better performance for large datasets due to its logarithmic time complexity. Linear Search becomes impractical as the input size grows, requiring on average n/2 comparisons.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative approach to avoid potential stack overflow issues with recursion.",
        "For very large datasets that don't fit in memory, consider using external binary search techniques."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, adding an initial sorting cost.",
        "Not suitable for unsorted data or when frequent insertions/deletions occur.",
        "Only applicable when a direct comparison can be made between elements."
      ]
    }
  ]
]
```
2025-04-01 16:10:36.234 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001138459s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002066s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "Binary Search offers significantly better performance for large datasets due to its logarithmic time complexity. Linear Search becomes impractical as the input size grows, requiring on average n/2 comparisons.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative approach to avoid potential stack overflow issues with recursion.",
        "For very large datasets that don't fit in memory, consider using external binary search techniques."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, adding an initial sorting cost.",
        "Not suitable for unsorted data or when frequent insertions/deletions occur.",
        "Only applicable when a direct comparison can be made between elements."
      ]
    }
  ]
]
```
2025-04-01 16:10:36.234 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00113845...
2025-04-01 16:10:36.234 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00113845...
2025-04-01 16:10:39.411 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 16:10:39.411 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 16:10:42.510 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0022345s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0021567s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0134578s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.0138901s"
    }
  ],
  [
    {
      "recommendation": "BFS and DFS",
      "insights": "For simple graph traversal without needing shortest paths, BFS and DFS provide the most efficient options with O(V+E) complexity. If shortest paths are required, Dijkstra's or Kruskal's should be considered, with Dijkstra's being preferable for single-source shortest paths and Kruskal's for finding Minimum Spanning Trees.",
      "performance_tips": [
        "Use adjacency lists for graph representation.",
        "Optimize queue/stack operations in BFS/DFS.",
        "Implement priority queue efficiently for Dijkstra's."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS.",
        "Dijkstra’s doesn't work with negative edge weights.",
        "Kruskal's requires sorting edges, which can be costly."
      ]
    }
  ]
]
```
2025-04-01 16:10:42.510 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0022345s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0021567s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0134578s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(E)",
      "execution_time_seconds": "0.0138901s"
    }
  ],
  [
    {
      "recommendation": "BFS and DFS",
      "insights": "For simple graph traversal without needing shortest paths, BFS and DFS provide the most efficient options with O(V+E) complexity. If shortest paths are required, Dijkstra's or Kruskal's should be considered, with Dijkstra's being preferable for single-source shortest paths and Kruskal's for finding Minimum Spanning Trees.",
      "performance_tips": [
        "Use adjacency lists for graph representation.",
        "Optimize queue/stack operations in BFS/DFS.",
        "Implement priority queue efficiently for Dijkstra's."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS.",
        "Dijkstra’s doesn't work with negative edge weights.",
        "Kruskal's requires sorting edges, which can be costly."
      ]
    }
  ]
]
```
2025-04-01 16:10:42.510 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 16:10:42.510 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 16:10:44.836 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:10:44.836 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:10:47.465 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001123456s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.402823669209385e+20s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial calculation using recursion has a linear time complexity, O(n). In contrast, Tower of Hanoi has exponential time complexity, O(2^n). For large 'n' values, factorial calculation is significantly faster and more practical.",
      "performance_tips": [
        "Use memoization for repeated calculations if the factorial is called multiple times with overlapping inputs.",
        "Consider tail-call optimization to reduce stack usage.",
        "Ensure the input 'n' is within reasonable bounds to prevent stack overflow errors in recursive implementations."
      ],
      "trade_offs": [
        "Recursive implementations can lead to stack overflow errors for very large 'n'.",
        "The space complexity is O(n) due to the call stack.",
        "For extremely large numbers exceeding available memory for intermediate results, specialized libraries for arbitrary-precision arithmetic might be needed."
      ]
    }
  ]
]
```
2025-04-01 16:10:47.465 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001123456s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.402823669209385e+20s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial calculation using recursion has a linear time complexity, O(n). In contrast, Tower of Hanoi has exponential time complexity, O(2^n). For large 'n' values, factorial calculation is significantly faster and more practical.",
      "performance_tips": [
        "Use memoization for repeated calculations if the factorial is called multiple times with overlapping inputs.",
        "Consider tail-call optimization to reduce stack usage.",
        "Ensure the input 'n' is within reasonable bounds to prevent stack overflow errors in recursive implementations."
      ],
      "trade_offs": [
        "Recursive implementations can lead to stack overflow errors for very large 'n'.",
        "The space complexity is O(n) due to the call stack.",
        "For extremely large numbers exceeding available memory for intermediate results, specialized libraries for arbitrary-precision arithmetic might be needed."
      ]
    }
  ]
]
```
2025-04-01 16:10:47.466 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:10:47.466 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:10:53.854 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:10:53.854 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:10:57.221 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2506413s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00498315s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1253131s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1251782s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00411232s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00487947s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:10:57.221 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2506413s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00498315s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1253131s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1251782s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00411232s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00487947s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:10:57.221 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2506413s"
...
2025-04-01 16:10:57.221 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2506413s"
...
2025-04-01 16:13:33.404 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:13:33.404 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:13:36.963 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247713958s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0045050925s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.25953355s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1262921s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00347592s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.004094075s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:13:36.963 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247713958s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0045050925s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.25953355s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1262921s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00347592s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.004094075s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:13:36.964 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247713958s...
2025-04-01 16:13:36.964 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247713958s...
2025-04-01 16:13:41.408 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:13:41.408 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:13:45.167 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0199873s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0111582s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0119435s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort, Heap Sort, Merge Sort",
      "insights": "Based on your input size and requirements, Quick Sort, Heap Sort, and Merge Sort perform best with O(nlogn) average time complexity. Although Quick Sort is generally the fastest in practice, Heap Sort has a guaranteed O(n log n) runtime and O(1) space complexity (in-place), and Merge sort is stable.",
      "performance_tips": [
        "Consider pivot selection strategy (Quick Sort).",
        "Optimize memory access patterns (all sorts).",
        "Utilize in-place sorting (Heap Sort)."
      ],
      "trade_offs": [
        "Quick Sort's worst-case O(n^2) time complexity is possible.",
        "Merge Sort has O(n) space complexity.",
        "Quick Sort is not a stable sorting algorithm."
      ]
    }
  ]
]
```
2025-04-01 16:13:45.167 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0199873s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0111582s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0119435s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort, Heap Sort, Merge Sort",
      "insights": "Based on your input size and requirements, Quick Sort, Heap Sort, and Merge Sort perform best with O(nlogn) average time complexity. Although Quick Sort is generally the fastest in practice, Heap Sort has a guaranteed O(n log n) runtime and O(1) space complexity (in-place), and Merge sort is stable.",
      "performance_tips": [
        "Consider pivot selection strategy (Quick Sort).",
        "Optimize memory access patterns (all sorts).",
        "Utilize in-place sorting (Heap Sort)."
      ],
      "trade_offs": [
        "Quick Sort's worst-case O(n^2) time complexity is possible.",
        "Merge Sort has O(n) space complexity.",
        "Quick Sort is not a stable sorting algorithm."
      ]
    }
  ]
]
```
2025-04-01 16:13:45.167 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-01 16:13:45.167 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-01 16:13:50.236 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 16:13:50.236 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 16:13:52.746 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001122531s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002135s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large datasets (n > 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. This makes it much faster for finding elements in sorted arrays.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid potential stack overflow issues with very large datasets.",
        "Be mindful of the integer overflow potential when calculating the middle index: mid = low + (high - low) / 2"
      ],
      "trade_offs": [
        "Requires the input array to be sorted, which may involve an additional sorting step if the array is not already sorted.",
        "Not suitable for unsorted data as it provides incorrect results.",
        "Only works efficiently on data structures that support random access, like arrays (not linked lists)."
      ]
    }
  ]
]
```
2025-04-01 16:13:52.746 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001122531s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002135s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large datasets (n > 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. This makes it much faster for finding elements in sorted arrays.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid potential stack overflow issues with very large datasets.",
        "Be mindful of the integer overflow potential when calculating the middle index: mid = low + (high - low) / 2"
      ],
      "trade_offs": [
        "Requires the input array to be sorted, which may involve an additional sorting step if the array is not already sorted.",
        "Not suitable for unsorted data as it provides incorrect results.",
        "Only works efficiently on data structures that support random access, like arrays (not linked lists)."
      ]
    }
  ]
]
```
2025-04-01 16:13:52.746 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00112253...
2025-04-01 16:13:52.746 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00112253...
2025-04-01 16:13:55.413 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 16:13:55.413 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-01 16:13:59.264 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00215234s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00207891s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.01392156s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.01300577s"
    }
  ],
  [
    {
      "recommendation": "BFS, DFS",
      "insights": "For simple graph traversal where the shortest path is not required and edge weights are uniform, BFS and DFS provide efficient solutions with time complexity O(V+E). In most graphs V will be less than E so O(E) is a good estimate. For n = 1,000,000 edges, this translates to roughly 0.001 seconds, plus or minus 20%. However, if shortest paths are necessary for weighted graphs, Dijkstra's or Kruskal's algorithm will be required, with the understanding that this comes with a performance penalty.",
      "performance_tips": [
        "Use adjacency lists for sparse graphs.",
        "Pre-allocate memory for visited nodes.",
        "Optimize queue/stack implementations (BFS/DFS)."
      ],
      "trade_offs": [
        "BFS: Finds shortest path (unweighted), uses more memory.",
        "DFS: Less memory, may not find shortest path, can get stuck in infinite loops.",
        "Dijkstra/Kruskal: Good for shortest path in weighted graphs, but slower than BFS/DFS."
      ]
    }
  ]
]
```
2025-04-01 16:13:59.264 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00215234s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.00207891s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.01392156s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.01300577s"
    }
  ],
  [
    {
      "recommendation": "BFS, DFS",
      "insights": "For simple graph traversal where the shortest path is not required and edge weights are uniform, BFS and DFS provide efficient solutions with time complexity O(V+E). In most graphs V will be less than E so O(E) is a good estimate. For n = 1,000,000 edges, this translates to roughly 0.001 seconds, plus or minus 20%. However, if shortest paths are necessary for weighted graphs, Dijkstra's or Kruskal's algorithm will be required, with the understanding that this comes with a performance penalty.",
      "performance_tips": [
        "Use adjacency lists for sparse graphs.",
        "Pre-allocate memory for visited nodes.",
        "Optimize queue/stack implementations (BFS/DFS)."
      ],
      "trade_offs": [
        "BFS: Finds shortest path (unweighted), uses more memory.",
        "DFS: Less memory, may not find shortest path, can get stuck in infinite loops.",
        "Dijkstra/Kruskal: Good for shortest path in weighted graphs, but slower than BFS/DFS."
      ]
    }
  ]
]
```
2025-04-01 16:13:59.265 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 16:13:59.265 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-01 16:14:02.598 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:14:02.598 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:14:05.320 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001123456s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.402823669209385e+20s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, the Tower of Hanoi calculation becomes computationally infeasible due to its exponential time complexity. While both algorithms are recursive, factorial calculation exhibits linear time complexity, making it far more efficient for large input sizes. The execution time for Tower of Hanoi with n=1,000,000 is astronomically large and practically impossible to compute.",
      "performance_tips": [
        "Use memoization to store intermediate results, although the space complexity may limit its effectiveness for extremely large n in factorial calculation.",
        "Tail-call optimization (if supported by the compiler/language) can help reduce stack overflow issues in factorial calculation.",
        "Consider using iterative approach for factorial calculation to further improve space complexity."
      ],
      "trade_offs": [
        "Factorial calculation has a much lower computational cost compared to Tower of Hanoi.",
        "Tower of Hanoi quickly becomes intractable as n increases.",
        "Space complexity of factorial calculation might be a concern for extremely large n."
      ]
    }
  ]
]
```
2025-04-01 16:14:05.320 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001123456s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.402823669209385e+20s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, the Tower of Hanoi calculation becomes computationally infeasible due to its exponential time complexity. While both algorithms are recursive, factorial calculation exhibits linear time complexity, making it far more efficient for large input sizes. The execution time for Tower of Hanoi with n=1,000,000 is astronomically large and practically impossible to compute.",
      "performance_tips": [
        "Use memoization to store intermediate results, although the space complexity may limit its effectiveness for extremely large n in factorial calculation.",
        "Tail-call optimization (if supported by the compiler/language) can help reduce stack overflow issues in factorial calculation.",
        "Consider using iterative approach for factorial calculation to further improve space complexity."
      ],
      "trade_offs": [
        "Factorial calculation has a much lower computational cost compared to Tower of Hanoi.",
        "Tower of Hanoi quickly becomes intractable as n increases.",
        "Space complexity of factorial calculation might be a concern for extremely large n."
      ]
    }
  ]
]
```
2025-04-01 16:14:05.320 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:14:05.320 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:14:09.631 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:14:09.631 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:14:12.032 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000009211s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000000011127s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a sorted dataset of medium size, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity.  Linear Search requires, on average, checking half the elements, while Binary Search repeatedly halves the search interval.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead.",
        "Be mindful of integer overflow when calculating the middle index in the search interval."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Only applicable to sorted data; not suitable for unsorted datasets.",
        "Slightly more complex to implement than Linear Search."
      ]
    }
  ]
]
```
2025-04-01 16:14:12.032 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000009211s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000000011127s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a sorted dataset of medium size, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity.  Linear Search requires, on average, checking half the elements, while Binary Search repeatedly halves the search interval.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead.",
        "Be mindful of integer overflow when calculating the middle index in the search interval."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Only applicable to sorted data; not suitable for unsorted datasets.",
        "Slightly more complex to implement than Linear Search."
      ]
    }
  ]
]
```
2025-04-01 16:14:12.033 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:14:12.033 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:18:15.156 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:18:15.156 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 16:18:18.558 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2529534s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0049988s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2578963s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1233158s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0028643s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0036157s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:18:18.558 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2529534s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0049988s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2578963s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1233158s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0028643s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0036157s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:18:18.559 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2529534s"
...
2025-04-01 16:18:18.559 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2529534s"
...
2025-04-01 16:18:22.752 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:18:22.752 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:18:26.730 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.998235772s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000110234723s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.491285335s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.408394668s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00007961655s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000103273866s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:18:26.730 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.998235772s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000110234723s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.491285335s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.408394668s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.00007961655s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000103273866s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:18:26.730 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:18:26.730 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:18:30.239 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:18:30.239 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-01 16:18:33.549 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0192000s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0160000s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0208000s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:18:33.549 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0192000s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "500.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0160000s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0208000s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 16:18:33.550 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-01 16:18:33.550 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-01 16:18:38.045 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 16:18:38.045 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-01 16:18:40.833 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011172s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002048s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes (n > 100000), Binary Search offers significantly better performance than Linear Search due to its logarithmic time complexity.  Binary Search requires the data to be sorted beforehand, which introduces an initial sorting cost, but for repeated searches, this initial cost is amortized over multiple queries. Linear Search, with its linear time complexity, becomes increasingly inefficient as the input size grows.  The estimated execution times clearly illustrate this difference.",
      "performance_tips": [
        "Ensure the input data is sorted before performing Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead (though the space difference here is often negligible).",
        "For extremely performance-critical scenarios, explore SIMD (Single Instruction, Multiple Data) optimizations if applicable to the underlying hardware."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Only applicable to sorted data.  Linear Search can be used on unsorted data.",
        "The benefits of Binary Search diminish if the data is frequently updated, as each update may require resorting."
      ]
    }
  ]
]
```
2025-04-01 16:18:40.833 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011172s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002048s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes (n > 100000), Binary Search offers significantly better performance than Linear Search due to its logarithmic time complexity.  Binary Search requires the data to be sorted beforehand, which introduces an initial sorting cost, but for repeated searches, this initial cost is amortized over multiple queries. Linear Search, with its linear time complexity, becomes increasingly inefficient as the input size grows.  The estimated execution times clearly illustrate this difference.",
      "performance_tips": [
        "Ensure the input data is sorted before performing Binary Search.",
        "Consider using iterative implementation to avoid recursion overhead (though the space difference here is often negligible).",
        "For extremely performance-critical scenarios, explore SIMD (Single Instruction, Multiple Data) optimizations if applicable to the underlying hardware."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Only applicable to sorted data.  Linear Search can be used on unsorted data.",
        "The benefits of Binary Search diminish if the data is frequently updated, as each update may require resorting."
      ]
    }
  ]
]
```
2025-04-01 16:18:40.834 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011172s...
2025-04-01 16:18:40.834 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011172s...
2025-04-01 16:18:43.061 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:18:43.061 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-01 16:18:45.584 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000010875s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000141621s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium-sized, *sorted* dataset (1000 < n < 100000), Binary Search significantly outperforms Linear Search. Binary search offers logarithmic time complexity, while linear search has linear time complexity. Thus, Binary search only requires a fraction of the processing time needed by Linear search.",
      "performance_tips": [
        "Ensure the data is sorted before applying binary search.",
        "Consider using an iterative approach for binary search to avoid potential stack overflow issues with very large datasets.",
        "For extremely performance-critical applications, explore optimized implementations of binary search."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which can incur an additional sorting cost if the data is not already sorted.",
        "Not suitable for unsorted data without prior sorting.",
        "Can be more complex to implement than linear search."
      ]
    }
  ]
]
```
2025-04-01 16:18:45.584 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000010875s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000141621s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium-sized, *sorted* dataset (1000 < n < 100000), Binary Search significantly outperforms Linear Search. Binary search offers logarithmic time complexity, while linear search has linear time complexity. Thus, Binary search only requires a fraction of the processing time needed by Linear search.",
      "performance_tips": [
        "Ensure the data is sorted before applying binary search.",
        "Consider using an iterative approach for binary search to avoid potential stack overflow issues with very large datasets.",
        "For extremely performance-critical applications, explore optimized implementations of binary search."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which can incur an additional sorting cost if the data is not already sorted.",
        "Not suitable for unsorted data without prior sorting.",
        "Can be more complex to implement than linear search."
      ]
    }
  ]
]
```
2025-04-01 16:18:45.585 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:18:45.585 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-01 16:18:46.974 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 16:18:46.974 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-01 16:18:49.329 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000589123s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000003876s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For small input sizes (n < 1000) and sorted data, Binary Search offers significantly better performance due to its logarithmic time complexity compared to Linear Search's linear time complexity. It's crucial the data is pre-sorted for Binary Search to work effectively. The execution time demonstrates the speed difference in practice.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid potential stack overflow issues.",
        "For very small arrays, the overhead of Binary Search might make Linear Search faster."
      ],
      "trade_offs": [
        "Requires the input data to be sorted.",
        "Only applicable to sorted arrays.",
        "More complex to implement than Linear Search."
      ]
    }
  ]
]
```
2025-04-01 16:18:49.329 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000589123s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000003876s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For small input sizes (n < 1000) and sorted data, Binary Search offers significantly better performance due to its logarithmic time complexity compared to Linear Search's linear time complexity. It's crucial the data is pre-sorted for Binary Search to work effectively. The execution time demonstrates the speed difference in practice.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid potential stack overflow issues.",
        "For very small arrays, the overhead of Binary Search might make Linear Search faster."
      ],
      "trade_offs": [
        "Requires the input data to be sorted.",
        "Only applicable to sorted arrays.",
        "More complex to implement than Linear Search."
      ]
    }
  ]
]
```
2025-04-01 16:18:49.329 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000589123s...
2025-04-01 16:18:49.329 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000589123s...
2025-04-01 16:18:52.910 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 16:18:52.910 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-01 16:18:56.297 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000546123s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000465892s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.003247654s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.003652987s"
    }
  ],
  [
    {
      "recommendation": "DFS, BFS",
      "insights": "For small graphs (n < 1000), both Depth-First Search (DFS) and Breadth-First Search (BFS) offer good performance due to their O(V + E) time complexity.  The choice between them depends on the specific problem. DFS is memory efficient when searching deep, whereas BFS finds the shortest path when all edge weights are equal.",
      "performance_tips": [
        "Use adjacency lists for graph representation.",
        "Optimize queue/stack operations in BFS/DFS.",
        "Avoid redundant node visits by using a visited array."
      ],
      "trade_offs": [
        "DFS can get stuck in infinite loops if the graph has cycles and a visited array is not used.",
        "Dijkstra's and Kruskal are only appropriate when edge weights are considered.",
        "Kruskal's is best for sparse graphs, while Dijkstra's performance depends on the graph's structure and priority queue implementation."
      ]
    }
  ]
]
```
2025-04-01 16:18:56.297 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000546123s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.000465892s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.003247654s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.003652987s"
    }
  ],
  [
    {
      "recommendation": "DFS, BFS",
      "insights": "For small graphs (n < 1000), both Depth-First Search (DFS) and Breadth-First Search (BFS) offer good performance due to their O(V + E) time complexity.  The choice between them depends on the specific problem. DFS is memory efficient when searching deep, whereas BFS finds the shortest path when all edge weights are equal.",
      "performance_tips": [
        "Use adjacency lists for graph representation.",
        "Optimize queue/stack operations in BFS/DFS.",
        "Avoid redundant node visits by using a visited array."
      ],
      "trade_offs": [
        "DFS can get stuck in infinite loops if the graph has cycles and a visited array is not used.",
        "Dijkstra's and Kruskal are only appropriate when edge weights are considered.",
        "Kruskal's is best for sparse graphs, while Dijkstra's performance depends on the graph's structure and priority queue implementation."
      ]
    }
  ]
]
```
2025-04-01 16:18:56.297 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 16:18:56.297 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_second...
2025-04-01 16:18:59.282 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:18:59.282 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Small (n < 1000)
2025-04-01 16:19:01.635 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000005688s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "4.1100000000s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For small values of n, factorial calculation is significantly faster than the Tower of Hanoi. Its O(n) time complexity compared to O(2^n) makes it drastically more efficient. While both are recursive, the exponential nature of Tower of Hanoi quickly becomes a bottleneck.",
      "performance_tips": [
        "Use memoization to avoid recalculating values.",
        "Ensure sufficient stack size for large recursive depths.",
        "Iterative solution can be faster in some cases."
      ],
      "trade_offs": [
        "Limited by integer size; can overflow quickly.",
        "Space complexity scales linearly with n (due to call stack).",
        "Not suitable for very large n due to stack overflow."
      ]
    }
  ]
]
```
2025-04-01 16:19:01.635 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0000005688s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "4.1100000000s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For small values of n, factorial calculation is significantly faster than the Tower of Hanoi. Its O(n) time complexity compared to O(2^n) makes it drastically more efficient. While both are recursive, the exponential nature of Tower of Hanoi quickly becomes a bottleneck.",
      "performance_tips": [
        "Use memoization to avoid recalculating values.",
        "Ensure sufficient stack size for large recursive depths.",
        "Iterative solution can be faster in some cases."
      ],
      "trade_offs": [
        "Limited by integer size; can overflow quickly.",
        "Space complexity scales linearly with n (due to call stack).",
        "Not suitable for very large n due to stack overflow."
      ]
    }
  ]
]
```
2025-04-01 16:19:01.635 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:19:01.635 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00...
2025-04-01 16:19:04.469 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:19:04.469 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-01 16:19:07.403 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001124123s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "4.556E+29s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, Factorial Calculation, with time complexity O(n) and space complexity O(n), significantly outperforms Tower of Hanoi with its exponential time complexity O(2^n). While both are recursive, the rapid growth of 2^n makes Tower of Hanoi impractical for n > 100000. The estimate execution time shows the significant difference. Note that for Factorial Calculation, for very large values of n, potential integer overflow should be handled using appropriate data structures (e.g., using libraries for arbitrary-precision arithmetic).",
      "performance_tips": [
        "Use memoization to avoid redundant calculations (applicable if calculating factorial of multiple numbers in a range).",
        "Consider iterative approach for slight performance gain in some implementations.",
        "Use tail recursion optimization, if supported by the compiler/language."
      ],
      "trade_offs": [
        "Space complexity O(n) due to recursion depth.",
        "Susceptible to stack overflow for very large n if tail recursion is not optimized.",
        "Integer overflow can occur for large n, requiring specialized data types or libraries."
      ]
    }
  ]
]
```
2025-04-01 16:19:07.403 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001124123s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "4.556E+29s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "For large n, Factorial Calculation, with time complexity O(n) and space complexity O(n), significantly outperforms Tower of Hanoi with its exponential time complexity O(2^n). While both are recursive, the rapid growth of 2^n makes Tower of Hanoi impractical for n > 100000. The estimate execution time shows the significant difference. Note that for Factorial Calculation, for very large values of n, potential integer overflow should be handled using appropriate data structures (e.g., using libraries for arbitrary-precision arithmetic).",
      "performance_tips": [
        "Use memoization to avoid redundant calculations (applicable if calculating factorial of multiple numbers in a range).",
        "Consider iterative approach for slight performance gain in some implementations.",
        "Use tail recursion optimization, if supported by the compiler/language."
      ],
      "trade_offs": [
        "Space complexity O(n) due to recursion depth.",
        "Susceptible to stack overflow for very large n if tail recursion is not optimized.",
        "Integer overflow can occur for large n, requiring specialized data types or libraries."
      ]
    }
  ]
]
```
2025-04-01 16:19:07.404 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 16:19:07.404 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-01 17:46:42.783 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 17:46:42.783 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 17:46:46.532 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.249847200s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004171700s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.204475200s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.104491500s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.002302150s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.003131000s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 17:46:46.532 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.249847200s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004171700s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.204475200s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.104491500s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.002302150s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.003131000s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 17:46:46.532 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.249847200s...
2025-04-01 17:46:46.532 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.249847200s...
2025-04-01 17:47:15.755 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 17:47:15.755 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 17:47:19.262 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.248351812s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004512958s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247572194s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.127700552s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.003713888s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.005286701s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 17:47:19.262 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.248351812s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004512958s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.247572194s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.127700552s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.003713888s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.005286701s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 17:47:19.262 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.248351812s...
2025-04-01 17:47:19.262 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.248351812s...
2025-04-01 17:47:19.846 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 17:47:19.846 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-01 17:47:23.226 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2502457s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0044911s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2473811s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1223895s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0031048s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0041121s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 17:47:23.226 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2502457s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0044911s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2473811s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1223895s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0031048s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0041121s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-01 17:47:23.226 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2502457s"
...
2025-04-01 17:47:23.226 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2502457s"
...
2025-04-01 19:00:59.989 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-01 19:00:59.989 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-02 08:19:26.610 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:19:26.610 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:22:17.078 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-02 08:22:17.078 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-02 08:23:44.669 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:23:44.669 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:24:19.678 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-02 08:24:19.678 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-02 08:24:22.636 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001015638s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002025s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Binary Search requires the data to be sorted, but the initial sorting cost is often justified when performing multiple searches.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using an iterative implementation to avoid potential stack overflow issues with very large datasets.",
        "For extremely performance-critical applications, explore vectorized binary search implementations (if applicable)."
      ],
      "trade_offs": [
        "Requires sorted input data, adding a potential pre-processing cost.",
        "Only applicable to sorted arrays or data structures that can be efficiently indexed.",
        "Not suitable for unsorted data where a single element needs to be found quickly without sorting."
      ]
    }
  ]
]
```
2025-04-02 08:24:22.636 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.001015638s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002025s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Binary Search requires the data to be sorted, but the initial sorting cost is often justified when performing multiple searches.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using an iterative implementation to avoid potential stack overflow issues with very large datasets.",
        "For extremely performance-critical applications, explore vectorized binary search implementations (if applicable)."
      ],
      "trade_offs": [
        "Requires sorted input data, adding a potential pre-processing cost.",
        "Only applicable to sorted arrays or data structures that can be efficiently indexed.",
        "Not suitable for unsorted data where a single element needs to be found quickly without sorting."
      ]
    }
  ]
]
```
2025-04-02 08:24:22.636 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00101563...
2025-04-02 08:24:22.636 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00101563...
2025-04-02 08:28:17.104 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-02 08:28:17.104 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-02 08:28:19.422 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011293748s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000021247s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a large sorted dataset (n > 100000), Binary Search is significantly more efficient than Linear Search. Its logarithmic time complexity allows it to find elements much faster.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative implementation for potential performance gains in some environments.",
        "For extremely large datasets, explore using B-trees or other indexing structures for further optimization."
      ],
      "trade_offs": [
        "Requires the data to be pre-sorted, which has its own time complexity cost.",
        "Only applicable to sorted data.",
        "Less efficient than Linear Search for very small datasets."
      ]
    }
  ]
]
```
2025-04-02 08:28:19.422 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011293748s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000021247s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a large sorted dataset (n > 100000), Binary Search is significantly more efficient than Linear Search. Its logarithmic time complexity allows it to find elements much faster.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative implementation for potential performance gains in some environments.",
        "For extremely large datasets, explore using B-trees or other indexing structures for further optimization."
      ],
      "trade_offs": [
        "Requires the data to be pre-sorted, which has its own time complexity cost.",
        "Only applicable to sorted data.",
        "Less efficient than Linear Search for very small datasets."
      ]
    }
  ]
]
```
2025-04-02 08:28:19.423 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00112937...
2025-04-02 08:28:19.423 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00112937...
2025-04-02 08:39:28.605 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-02 08:39:28.605 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-02 08:39:31.525 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:39:31.525 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:39:39.640 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:39:39.640 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:39:44.221 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-02 08:39:44.221 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-02 08:39:46.885 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005784s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000039s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a small, sorted dataset of n < 1000, Binary Search is significantly faster than Linear Search due to its logarithmic time complexity. While Linear Search examines each element sequentially, Binary Search repeatedly divides the search interval in half. This drastically reduces the number of comparisons needed to find the target element, resulting in superior performance for larger 'n'.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative approach instead of recursion to avoid potential stack overflow issues for very large datasets (though unlikely for n < 1000).",
        "Implement early exit conditions if the target is found to avoid unnecessary iterations."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Only applicable when searching for a specific value within an ordered dataset.",
        "Less efficient than Linear Search if the target element is located at the very beginning of the unsorted data."
      ]
    }
  ]
]
```
2025-04-02 08:39:46.885 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005784s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000039s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a small, sorted dataset of n < 1000, Binary Search is significantly faster than Linear Search due to its logarithmic time complexity. While Linear Search examines each element sequentially, Binary Search repeatedly divides the search interval in half. This drastically reduces the number of comparisons needed to find the target element, resulting in superior performance for larger 'n'.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative approach instead of recursion to avoid potential stack overflow issues for very large datasets (though unlikely for n < 1000).",
        "Implement early exit conditions if the target is found to avoid unnecessary iterations."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which adds an initial sorting cost if the data is not already sorted.",
        "Only applicable when searching for a specific value within an ordered dataset.",
        "Less efficient than Linear Search if the target element is located at the very beginning of the unsorted data."
      ]
    }
  ]
]
```
2025-04-02 08:39:46.885 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005784s"
...
2025-04-02 08:39:46.885 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0005784s"
...
2025-04-02 08:41:49.855 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-02 08:41:49.855 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-02 08:41:52.753 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:41:52.753 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:42:03.032 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:42:03.032 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-02 08:44:25.934 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-02 08:44:25.934 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-02 08:44:29.264 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000118525s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000109346s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium input size (1000 < n < 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. However, Binary Search requires the input data to be sorted.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative implementation to avoid potential stack overflow issues for extremely large datasets (although unlikely for this input size).",
        "Optimize the comparison operation for specific data types."
      ],
      "trade_offs": [
        "Requires the input array to be sorted, adding a potential O(n log n) sorting overhead if the data is not already sorted.",
        "Not suitable for unsorted data.",
        "Can be more complex to implement than Linear Search."
      ]
    }
  ]
]
```
2025-04-02 08:44:29.264 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000118525s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000109346s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium input size (1000 < n < 100000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. However, Binary Search requires the input data to be sorted.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative implementation to avoid potential stack overflow issues for extremely large datasets (although unlikely for this input size).",
        "Optimize the comparison operation for specific data types."
      ],
      "trade_offs": [
        "Requires the input array to be sorted, adding a potential O(n log n) sorting overhead if the data is not already sorted.",
        "Not suitable for unsorted data.",
        "Can be more complex to implement than Linear Search."
      ]
    }
  ]
]
```
2025-04-02 08:44:29.265 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-02 08:44:29.265 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-02 08:44:51.702 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-02 08:44:51.702 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-02 08:44:54.204 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011352s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002121s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Linear Search requires checking each element in the worst case, while Binary Search halves the search space with each comparison. This makes Binary Search much faster for finding elements in sorted arrays of this size.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid potential stack overflow issues with very large datasets.",
        "Optimize for cache performance by ensuring data is aligned and accessed sequentially."
      ],
      "trade_offs": [
        "Requires the input array to be sorted, which adds overhead if the array is not already sorted.",
        "Only applicable to sorted data.",
        "Can be less efficient than other search methods for extremely small datasets due to the overhead of maintaining the sorted order and the initial comparison operations."
      ]
    }
  ]
]
```
2025-04-02 08:44:54.204 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011352s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002121s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Linear Search requires checking each element in the worst case, while Binary Search halves the search space with each comparison. This makes Binary Search much faster for finding elements in sorted arrays of this size.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using iterative implementation to avoid potential stack overflow issues with very large datasets.",
        "Optimize for cache performance by ensuring data is aligned and accessed sequentially."
      ],
      "trade_offs": [
        "Requires the input array to be sorted, which adds overhead if the array is not already sorted.",
        "Only applicable to sorted data.",
        "Can be less efficient than other search methods for extremely small datasets due to the overhead of maintaining the sorted order and the initial comparison operations."
      ]
    }
  ]
]
```
2025-04-02 08:44:54.205 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011352s...
2025-04-02 08:44:54.205 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011352s...
2025-04-02 08:45:05.704 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-02 08:45:05.704 | INFO     | main:compare:151 - Sending prompt to Gemini: Recursion Algorithms, Large (n > 100000)
2025-04-02 08:45:08.172 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001054795s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.53809E+30s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial calculation demonstrates linear time complexity O(n) and scales much better for large n compared to Tower of Hanoi. The stack space used grows linearly with n, but this is manageable for the specified input size. Tower of Hanoi, with O(2^n) complexity, becomes completely impractical for n > 100000 due to its exponential nature, making factorial calculation the only reasonable choice.",
      "performance_tips": [
        "Use memoization (though already implied due to recursion)",
        "Consider iterative implementation for large factorials (potentially avoiding stack overflow)",
        "Optimize base case handling"
      ],
      "trade_offs": [
        "Stack overflow for extremely large n (can be mitigated with tail recursion or iterative approach)",
        "Space complexity is O(n) due to call stack",
        "Limited by integer size (for very large n, arbitrary-precision arithmetic is needed)"
      ]
    }
  ]
]
```
2025-04-02 08:45:08.172 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.001054795s"
    },
    {
      "algorithm": "Tower of Hanoi Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "3.53809E+30s"
    }
  ],
  [
    {
      "recommendation": "Factorial Calculation",
      "insights": "Factorial calculation demonstrates linear time complexity O(n) and scales much better for large n compared to Tower of Hanoi. The stack space used grows linearly with n, but this is manageable for the specified input size. Tower of Hanoi, with O(2^n) complexity, becomes completely impractical for n > 100000 due to its exponential nature, making factorial calculation the only reasonable choice.",
      "performance_tips": [
        "Use memoization (though already implied due to recursion)",
        "Consider iterative implementation for large factorials (potentially avoiding stack overflow)",
        "Optimize base case handling"
      ],
      "trade_offs": [
        "Stack overflow for extremely large n (can be mitigated with tail recursion or iterative approach)",
        "Space complexity is O(n) due to call stack",
        "Limited by integer size (for very large n, arbitrary-precision arithmetic is needed)"
      ]
    }
  ]
]
```
2025-04-02 08:45:08.172 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-02 08:45:08.172 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Factorial Calculation",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0....
2025-04-02 08:45:21.831 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-02 08:45:21.831 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-02 08:45:25.075 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0021113s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0019635s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0139562s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0130015s"
    }
  ],
  [
    {
      "recommendation": "BFS, DFS",
      "insights": "For simple graph traversal without weighted edges or specific pathfinding requirements, BFS and DFS are often the most efficient choices, with a time complexity of O(V+E). Dijkstra's and Kruskal's algorithms are designed for more specific purposes, such as finding shortest paths or minimum spanning trees, and have higher time complexities.",
      "performance_tips": [
        "Use adjacency lists for graph representation to minimize memory usage.",
        "Optimize data structures used for queue/stack in BFS/DFS.",
        "Avoid redundant computations."
      ],
      "trade_offs": [
        "BFS guarantees shortest path in unweighted graphs but may require more memory than DFS.",
        "DFS may find paths quicker in some cases, but doesn't guarantee the shortest path and is prone to stack overflow in very deep graphs.",
        "Dijkstra's and Kruskal’s are slower for simple traversal but essential for shortest path or minimum spanning tree problems."
      ]
    }
  ]
]
```
2025-04-02 08:45:25.075 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0021113s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0019635s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0139562s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0130015s"
    }
  ],
  [
    {
      "recommendation": "BFS, DFS",
      "insights": "For simple graph traversal without weighted edges or specific pathfinding requirements, BFS and DFS are often the most efficient choices, with a time complexity of O(V+E). Dijkstra's and Kruskal's algorithms are designed for more specific purposes, such as finding shortest paths or minimum spanning trees, and have higher time complexities.",
      "performance_tips": [
        "Use adjacency lists for graph representation to minimize memory usage.",
        "Optimize data structures used for queue/stack in BFS/DFS.",
        "Avoid redundant computations."
      ],
      "trade_offs": [
        "BFS guarantees shortest path in unweighted graphs but may require more memory than DFS.",
        "DFS may find paths quicker in some cases, but doesn't guarantee the shortest path and is prone to stack overflow in very deep graphs.",
        "Dijkstra's and Kruskal’s are slower for simple traversal but essential for shortest path or minimum spanning tree problems."
      ]
    }
  ]
]
```
2025-04-02 08:45:25.075 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-02 08:45:25.075 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-02 08:45:34.860 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-02 08:45:34.860 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-02 08:45:38.165 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0022354s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0020768s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0139183s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0135411s"
    }
  ],
  [
    {
      "recommendation": "BFS, DFS",
      "insights": "For large graphs (n > 100000), the choice between BFS and DFS depends largely on the specific application. Both have the same time complexity O(V+E). Dijkstra's and Kruskal's algorithms, which are used for finding shortest paths or minimum spanning trees, have higher time complexities (O(E log V) and O(E log E) respectively), making them slower for general graph traversal.",
      "performance_tips": [
        "Use adjacency lists for graph representation.",
        "Optimize queue/stack operations in BFS/DFS.",
        "For Dijkstra, consider using a Fibonacci heap for priority queue if applicable for your use case."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS.",
        "DFS can get stuck in infinite loops if not implemented carefully.",
        "Dijkstra's algorithm is only suitable for graphs with non-negative edge weights."
      ]
    }
  ]
]
```
2025-04-02 08:45:38.165 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0022354s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0020768s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0139183s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.0135411s"
    }
  ],
  [
    {
      "recommendation": "BFS, DFS",
      "insights": "For large graphs (n > 100000), the choice between BFS and DFS depends largely on the specific application. Both have the same time complexity O(V+E). Dijkstra's and Kruskal's algorithms, which are used for finding shortest paths or minimum spanning trees, have higher time complexities (O(E log V) and O(E log E) respectively), making them slower for general graph traversal.",
      "performance_tips": [
        "Use adjacency lists for graph representation.",
        "Optimize queue/stack operations in BFS/DFS.",
        "For Dijkstra, consider using a Fibonacci heap for priority queue if applicable for your use case."
      ],
      "trade_offs": [
        "BFS uses more memory than DFS.",
        "DFS can get stuck in infinite loops if not implemented carefully.",
        "Dijkstra's algorithm is only suitable for graphs with non-negative edge weights."
      ]
    }
  ]
]
```
2025-04-02 08:45:38.166 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-02 08:45:38.166 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-02 08:46:45.486 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-02 08:46:45.486 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Large (n > 100000)
2025-04-02 08:46:49.427 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002145321s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002034789s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.014123876s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.014987234s"
    }
  ],
  [
    {
      "recommendation": "BFS, DFS",
      "insights": "For a large graph (n > 100000), BFS and DFS are typically faster for basic traversal because their time complexity is O(V+E), where V is the number of vertices and E is the number of edges.  Assuming a connected graph, E will generally be larger than V, but for sparse graphs, the log factors in Dijkstra's and Kruskal's algorithms can make them slower. Dijkstra's algorithm is suitable if you need to find the shortest path from a single source, while Kruskal's is suitable if you need to find the minimum spanning tree.  The estimated times reflect a graph where E is roughly 5V, meaning both V and E are large (on the order of 1,000,000 vertices and 5,000,000 edges).",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs.",
        "For BFS, use a queue efficiently.",
        "For DFS, avoid cycles to prevent infinite loops."
      ],
      "trade_offs": [
        "BFS guarantees shortest path on unweighted graphs, DFS doesn't.",
        "Dijkstra's finds shortest paths from a single source, but doesn't work with negative edge weights.",
        "Kruskal's finds minimum spanning tree, but requires a disjoint-set data structure for efficient implementation."
      ]
    }
  ]
]
```
2025-04-02 08:46:49.427 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002145321s"
    },
    {
      "algorithm": "Depth-First Search (DFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.002034789s"
    },
    {
      "algorithm": "Dijkstra’s",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log V)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.014123876s"
    },
    {
      "algorithm": "Kruskal",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(E log E)",
      "space_complexity": "O(V)",
      "execution_time_seconds": "0.014987234s"
    }
  ],
  [
    {
      "recommendation": "BFS, DFS",
      "insights": "For a large graph (n > 100000), BFS and DFS are typically faster for basic traversal because their time complexity is O(V+E), where V is the number of vertices and E is the number of edges.  Assuming a connected graph, E will generally be larger than V, but for sparse graphs, the log factors in Dijkstra's and Kruskal's algorithms can make them slower. Dijkstra's algorithm is suitable if you need to find the shortest path from a single source, while Kruskal's is suitable if you need to find the minimum spanning tree.  The estimated times reflect a graph where E is roughly 5V, meaning both V and E are large (on the order of 1,000,000 vertices and 5,000,000 edges).",
      "performance_tips": [
        "Use adjacency list representation for sparse graphs.",
        "For BFS, use a queue efficiently.",
        "For DFS, avoid cycles to prevent infinite loops."
      ],
      "trade_offs": [
        "BFS guarantees shortest path on unweighted graphs, DFS doesn't.",
        "Dijkstra's finds shortest paths from a single source, but doesn't work with negative edge weights.",
        "Kruskal's finds minimum spanning tree, but requires a disjoint-set data structure for efficient implementation."
      ]
    }
  ]
]
```
2025-04-02 08:46:49.427 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-02 08:46:49.427 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Breadth-First Search (BFS)",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V)",
      "execution_time_seco...
2025-04-02 08:48:06.419 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-02 08:48:06.419 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Large (n > 100000)
2025-04-02 08:48:08.525 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011334s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002408s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Binary search requires the data to be sorted.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative implementation to avoid potential stack overflow issues for extremely large arrays.",
        "Optimize memory access patterns to improve cache utilization."
      ],
      "trade_offs": [
        "Requires a sorted input array, which incurs sorting overhead if the data is not already sorted.",
        "Not suitable for unsorted data or frequently changing data.",
        "Only applicable when direct access to the middle element is possible."
      ]
    }
  ]
]
```
2025-04-02 08:48:08.525 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011334s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000002408s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For large input sizes, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Binary search requires the data to be sorted.",
      "performance_tips": [
        "Ensure the input array is sorted before applying Binary Search.",
        "Consider using an iterative implementation to avoid potential stack overflow issues for extremely large arrays.",
        "Optimize memory access patterns to improve cache utilization."
      ],
      "trade_offs": [
        "Requires a sorted input array, which incurs sorting overhead if the data is not already sorted.",
        "Not suitable for unsorted data or frequently changing data.",
        "Only applicable when direct access to the middle element is possible."
      ]
    }
  ]
]
```
2025-04-02 08:48:08.525 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011334s...
2025-04-02 08:48:08.525 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0011334s...
2025-04-02 08:48:18.217 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-02 08:48:18.217 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Large (n > 100000)
2025-04-02 08:48:22.108 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0199999s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0199999s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0199999s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort, Merge Sort, Heap Sort",
      "insights": "Based on your input size and requirements, Quick Sort, Merge Sort, and Heap Sort are the top performers, providing O(n log n) average time complexity. They showed superior performance in benchmarks for the given dataset size, as algorithms with O(n^2) become extremely slow for large n. Quick Sort generally has the best performance due to lower constant factors. Heap Sort has guaranteed O(n log n) time complexity, unlike Quick Sort's worst-case O(n^2). Merge Sort requires O(n) extra space.",
      "performance_tips": [
        "Consider pivot selection strategy (Quick Sort).",
        "Optimize memory access patterns (Merge Sort).",
        "Use bottom-up approach for Heap Sort (if possible)."
      ],
      "trade_offs": [
        "Quick Sort is not stable, and its worst-case is O(n^2).",
        "Merge Sort requires extra space O(n).",
        "Heap Sort might have slower performance in practice compared to Quick Sort due to constant factors."
      ]
    }
  ]
]
```
2025-04-02 08:48:22.108 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.0199999s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.0000000s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0199999s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0199999s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort, Merge Sort, Heap Sort",
      "insights": "Based on your input size and requirements, Quick Sort, Merge Sort, and Heap Sort are the top performers, providing O(n log n) average time complexity. They showed superior performance in benchmarks for the given dataset size, as algorithms with O(n^2) become extremely slow for large n. Quick Sort generally has the best performance due to lower constant factors. Heap Sort has guaranteed O(n log n) time complexity, unlike Quick Sort's worst-case O(n^2). Merge Sort requires O(n) extra space.",
      "performance_tips": [
        "Consider pivot selection strategy (Quick Sort).",
        "Optimize memory access patterns (Merge Sort).",
        "Use bottom-up approach for Heap Sort (if possible)."
      ],
      "trade_offs": [
        "Quick Sort is not stable, and its worst-case is O(n^2).",
        "Merge Sort requires extra space O(n).",
        "Heap Sort might have slower performance in practice compared to Quick Sort due to constant factors."
      ]
    }
  ]
]
```
2025-04-02 08:48:22.109 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-02 08:48:22.109 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Large (n > 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "1000.00000...
2025-04-02 08:52:34.851 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-02 08:52:34.851 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-02 08:52:38.566 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.25344784s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004669725s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.27553965s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1290348s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.003853665s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.005188165s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort, Insertion Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). Insertion Sort, while O(n^2) in general, performs very well when the input array is nearly sorted. Consider using Insertion Sort as a final step in Quick Sort for small subarrays to improve performance.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization (Quick Sort).",
        "Use insertion sort for small subarrays (Quick Sort)."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm (Quick Sort).",
        "Worst-case O(n^2) time complexity is possible (Quick Sort).",
        "Performance highly depends on pivot choice (Quick Sort)."
      ]
    }
  ]
]
```
2025-04-02 08:52:38.566 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.25344784s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.004669725s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.27553965s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1290348s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.003853665s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.005188165s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort, Insertion Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). Insertion Sort, while O(n^2) in general, performs very well when the input array is nearly sorted. Consider using Insertion Sort as a final step in Quick Sort for small subarrays to improve performance.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization (Quick Sort).",
        "Use insertion sort for small subarrays (Quick Sort)."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm (Quick Sort).",
        "Worst-case O(n^2) time complexity is possible (Quick Sort).",
        "Performance highly depends on pivot choice (Quick Sort)."
      ]
    }
  ]
]
```
2025-04-02 08:52:38.566 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.25344784s"...
2025-04-02 08:52:38.566 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.25344784s"...
2025-04-02 08:52:46.260 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-02 08:52:46.260 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Medium (1000 < n < 100000)
2025-04-02 08:52:49.768 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.883241489s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000105755s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.684517561s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.529811782s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.000087641s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000110947s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-02 08:52:49.768 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.883241489s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.000105755s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.684517561s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.529811782s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.000087641s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000110947s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n^2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-02 08:52:49.768 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-02 08:52:49.768 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-02 08:52:53.124 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-02 08:52:53.124 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-02 08:52:56.437 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000009423s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000000012s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium input size (1000 < n < 100000) and if the data is sorted, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity.  Linear search requires, on average, checking half of the elements, while Binary Search halves the search space with each comparison.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using iterative implementation for potentially better performance due to reduced function call overhead.",
        "For very small arrays, Linear Search might be faster due to the overhead of Binary Search setup."
      ],
      "trade_offs": [
        "Requires sorted input data; sorting adds overhead if the data is not already sorted.",
        "Not suitable for unsorted data.",
        "Can be less efficient than Linear Search for very small datasets."
      ]
    }
  ]
]
```
2025-04-02 08:52:56.437 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000009423s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000000012s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium input size (1000 < n < 100000) and if the data is sorted, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity.  Linear search requires, on average, checking half of the elements, while Binary Search halves the search space with each comparison.",
      "performance_tips": [
        "Ensure the input data is sorted before applying Binary Search.",
        "Consider using iterative implementation for potentially better performance due to reduced function call overhead.",
        "For very small arrays, Linear Search might be faster due to the overhead of Binary Search setup."
      ],
      "trade_offs": [
        "Requires sorted input data; sorting adds overhead if the data is not already sorted.",
        "Not suitable for unsorted data.",
        "Can be less efficient than Linear Search for very small datasets."
      ]
    }
  ]
]
```
2025-04-02 08:52:56.437 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-02 08:52:56.437 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-04 11:43:11.226 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-04 11:43:11.226 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-04 12:47:35.960 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-04 12:47:35.960 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Medium (1000 < n < 100000)
2025-04-04 12:47:39.311 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000118133584s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000000010040568s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium-sized, sorted dataset, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Linear Search requires checking each element in the worst case, whereas Binary Search efficiently narrows down the search range by half with each comparison.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative approach for better space efficiency in some implementations.",
        "Be mindful of integer overflow when calculating the middle index."
      ],
      "trade_offs": [
        "Requires the input data to be sorted.",
        "Not suitable for unsorted or frequently changing datasets.",
        "Only applicable when direct access to elements is possible."
      ]
    }
  ]
]
```
2025-04-04 12:47:39.311 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000118133584s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000000010040568s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a medium-sized, sorted dataset, Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Linear Search requires checking each element in the worst case, whereas Binary Search efficiently narrows down the search range by half with each comparison.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider using an iterative approach for better space efficiency in some implementations.",
        "Be mindful of integer overflow when calculating the middle index."
      ],
      "trade_offs": [
        "Requires the input data to be sorted.",
        "Not suitable for unsorted or frequently changing datasets.",
        "Only applicable when direct access to elements is possible."
      ]
    }
  ]
]
```
2025-04-04 12:47:39.311 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-04 12:47:39.311 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Medium (1000 < n < 100000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0....
2025-04-04 15:20:11.505 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-04 15:20:11.505 | INFO     | main:compare:151 - Sending prompt to Gemini: Sorting Algorithms, Small (n < 1000)
2025-04-04 15:20:15.034 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2501095s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00451915s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2435032s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1221787s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0037432s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00409585s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-04 15:20:15.034 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2501095s"
    },
    {
      "algorithm": "Merge Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "execution_time_seconds": "0.00451915s"
    },
    {
      "algorithm": "Selection Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2435032s"
    },
    {
      "algorithm": "Insertion Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.1221787s"
    },
    {
      "algorithm": "Quick Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(log n)",
      "execution_time_seconds": "0.0037432s"
    },
    {
      "algorithm": "Heap Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.00409585s"
    }
  ],
  [
    {
      "recommendation": "Quick Sort",
      "insights": "Based on your input size and requirements, Quick Sort performs best with O(nlogn) average time complexity and relatively minimal space usage (O(logn) average). It showed superior performance in benchmarks for the given dataset size.",
      "performance_tips": [
        "Consider pivot selection strategy.",
        "Implement tail-call optimization.",
        "Use insertion sort for small subarrays."
      ],
      "trade_offs": [
        "Not a stable sorting algorithm.",
        "Worst-case O(n2) time complexity is possible.",
        "Performance highly depends on pivot choice."
      ]
    }
  ]
]
```
2025-04-04 15:20:15.034 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2501095s"
...
2025-04-04 15:20:15.034 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Bubble Sort",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.2501095s"
...
2025-04-04 15:20:53.883 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-04 15:20:53.883 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-04 15:20:56.311 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000005532s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000481s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a small, *sorted* dataset (n < 1000), Binary Search offers significantly faster search times compared to Linear Search due to its logarithmic time complexity.  Linear search examines each element sequentially, while Binary Search repeatedly divides the search interval in half.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "For very small datasets, the overhead of Binary Search might make Linear Search faster in practice. Consider a hybrid approach.",
        "Implementation can be iterative or recursive, but the iterative version usually has slightly better performance due to reduced overhead."
      ],
      "trade_offs": [
        "Requires the data to be sorted beforehand, which adds an initial sorting cost if the data is not already sorted.",
        "Only applicable to sorted data; Linear Search works on unsorted data.",
        "Potentially more complex to implement correctly compared to Linear Search."
      ]
    }
  ]
]
```
2025-04-04 15:20:56.311 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000005532s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000000481s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a small, *sorted* dataset (n < 1000), Binary Search offers significantly faster search times compared to Linear Search due to its logarithmic time complexity.  Linear search examines each element sequentially, while Binary Search repeatedly divides the search interval in half.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "For very small datasets, the overhead of Binary Search might make Linear Search faster in practice. Consider a hybrid approach.",
        "Implementation can be iterative or recursive, but the iterative version usually has slightly better performance due to reduced overhead."
      ],
      "trade_offs": [
        "Requires the data to be sorted beforehand, which adds an initial sorting cost if the data is not already sorted.",
        "Only applicable to sorted data; Linear Search works on unsorted data.",
        "Potentially more complex to implement correctly compared to Linear Search."
      ]
    }
  ]
]
```
2025-04-04 15:20:56.311 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000005532...
2025-04-04 15:20:56.311 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.0000005532...
2025-04-04 21:22:35.650 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-04 21:22:35.650 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-05 17:50:45.836 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-05 17:50:45.836 | INFO     | main:compare:151 - Sending prompt to Gemini: Graph Traversal, Small (n < 1000)
2025-04-05 17:50:49.263 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001086151s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.000912338s"},
    {"algorithm": "Dijkstra’s", "input_size": "Small (n < 1000)", "time_complexity": "O(E log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.002487387s"},
    {"algorithm": "Kruskal", "input_size": "Small (n < 1000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.002849231s"}
  ],
  [
    {"recommendation": "Depth-First Search (DFS)", "insights": "For a small graph (n < 1000), DFS and BFS are generally comparable in speed, with their execution time primarily determined by the graph's structure. DFS often has a slight advantage due to potentially lower overhead from queue operations compared to BFS. Dijkstra's and Kruskal's algorithms are more computationally intensive, suitable when specific pathfinding and minimum spanning tree problems exist, respectively. If the specific needs aren't related to Shortest Path or MSTs, DFS offers a simpler and efficient graph exploration.", "performance_tips": ["Use an adjacency list representation for sparse graphs.", "Avoid redundant visits by marking visited nodes.", "Optimize stack size for very deep graphs."], "trade_offs": ["May not find the shortest path in unweighted graphs.", "Can get stuck in infinite loops in cyclic graphs if not implemented carefully.", "Recursion can lead to stack overflow errors in deep graphs."]}
  ]
]
```
2025-04-05 17:50:49.263 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001086151s"},
    {"algorithm": "Depth-First Search (DFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.000912338s"},
    {"algorithm": "Dijkstra’s", "input_size": "Small (n < 1000)", "time_complexity": "O(E log V)", "space_complexity": "O(V)", "execution_time_seconds": "0.002487387s"},
    {"algorithm": "Kruskal", "input_size": "Small (n < 1000)", "time_complexity": "O(E log E)", "space_complexity": "O(E)", "execution_time_seconds": "0.002849231s"}
  ],
  [
    {"recommendation": "Depth-First Search (DFS)", "insights": "For a small graph (n < 1000), DFS and BFS are generally comparable in speed, with their execution time primarily determined by the graph's structure. DFS often has a slight advantage due to potentially lower overhead from queue operations compared to BFS. Dijkstra's and Kruskal's algorithms are more computationally intensive, suitable when specific pathfinding and minimum spanning tree problems exist, respectively. If the specific needs aren't related to Shortest Path or MSTs, DFS offers a simpler and efficient graph exploration.", "performance_tips": ["Use an adjacency list representation for sparse graphs.", "Avoid redundant visits by marking visited nodes.", "Optimize stack size for very deep graphs."], "trade_offs": ["May not find the shortest path in unweighted graphs.", "Can get stuck in infinite loops in cyclic graphs if not implemented carefully.", "Recursion can lead to stack overflow errors in deep graphs."]}
  ]
]
```
2025-04-05 17:50:49.263 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001086151s"},
    {"algo...
2025-04-05 17:50:49.263 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {"algorithm": "Breadth-First Search (BFS)", "input_size": "Small (n < 1000)", "time_complexity": "O(V + E)", "space_complexity": "O(V)", "execution_time_seconds": "0.001086151s"},
    {"algo...
2025-04-06 20:15:05.241 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-06 20:15:05.241 | INFO     | main:compare:151 - Sending prompt to Gemini: Search Algorithms, Small (n < 1000)
2025-04-06 20:15:07.574 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000578293s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000003827s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a small, sorted dataset (n < 1000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Even with overhead, the reduced number of comparisons makes it much faster.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider interpolation search if the data is uniformly distributed.",
        "Be mindful of the overhead of sorting if the data is frequently modified."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which can add O(n log n) time if sorting is needed.",
        "Not suitable for unsorted data.",
        "More complex to implement than Linear Search."
      ]
    }
  ]
]
```
2025-04-06 20:15:07.574 | INFO     | main:compare:155 - Raw Gemini response (full): ```json
[
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000578293s"
    },
    {
      "algorithm": "Binary Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000003827s"
    }
  ],
  [
    {
      "recommendation": "Binary Search",
      "insights": "For a small, sorted dataset (n < 1000), Binary Search significantly outperforms Linear Search due to its logarithmic time complexity. Even with overhead, the reduced number of comparisons makes it much faster.",
      "performance_tips": [
        "Ensure the data is sorted before applying Binary Search.",
        "Consider interpolation search if the data is uniformly distributed.",
        "Be mindful of the overhead of sorting if the data is frequently modified."
      ],
      "trade_offs": [
        "Requires the input data to be sorted, which can add O(n log n) time if sorting is needed.",
        "Not suitable for unsorted data.",
        "More complex to implement than Linear Search."
      ]
    }
  ]
]
```
2025-04-06 20:15:07.574 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000578293s...
2025-04-06 20:15:07.574 | INFO     | main:compare:183 - Extracted JSON portion: [
  [
    {
      "algorithm": "Linear Search",
      "input_size": "Small (n < 1000)",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "execution_time_seconds": "0.000578293s...
2025-04-06 22:19:24.258 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-06 22:19:24.258 | INFO     | main:lifespan:15 - Starting up FastAPI application
2025-04-06 22:19:28.435 | INFO     | main:lifespan:17 - Shutting down FastAPI application
2025-04-06 22:19:28.435 | INFO     | main:lifespan:17 - Shutting down FastAPI application
